<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no">
    <title>ACES Star Formation Tour</title>
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src='https://aladin.cds.unistra.fr/AladinLite/api/v3/latest/aladin.js' charset='utf-8'></script>
    <!-- Add draggable functionality -->
    <script type="text/javascript" src="draggable.js"></script>
    <link rel="stylesheet" href="default.css">
    <link rel="stylesheet" href="draggable.css">
    <style>
        /* Mobile-friendly improvements */
        #progress-container {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #progress-bar {
            flex: 1;
            height: 4px !important;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            overflow: hidden;
        }

        #progress {
            height: 100%;
            background: #2962FF;
            transition: width 0.3s ease;
        }

        #current-waypoint {
            color: white;
            font-size: 14px;
            font-weight: bold;
            min-width: 30px;
            text-align: center;
        }

        #tour-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            width: 100%;
            max-width: 100vw;
            box-sizing: border-box;
            padding: 0 10px;
        }

        /* Desktop: only as wide as needed */
        @media (min-width: 769px) {
            #tour-controls {
                width: fit-content;
                padding: 0;
            }
        }

        #tour-controls button {
            background: #2962FF;
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            min-width: 48px;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }

        #tour-controls button:hover {
            background: #1976D2;
        }

        #tour-controls button:active {
            background: #0D47A1;
        }

        #tour-controls button:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
        }

        #tour-controls button:disabled:hover {
            background: #666;
        }

        #waypoint-info {
            max-width: 90vw;
            transition: all 0.3s ease;
        }

        /* Override any default positioning for mobile only */
        @media (max-width: 768px) {
            #waypoint-info {
                position: relative !important;
                left: auto !important;
                right: auto !important;
                top: auto !important;
                bottom: auto !important;
                width: fit-content !important;
                max-width: calc(100vw - 20px) !important;
                margin: 10px auto !important;
            }
        }

        /* Desktop: static positioning on top-right */
        @media (min-width: 769px) {
            #waypoint-info {
                position: absolute !important;
                width: auto !important;
                max-width: 400px !important;
                margin: 0 !important;
                left: auto !important;
                right: 20px !important;
                top: 20px !important;
                bottom: auto !important;
                transform: none !important;
                min-width: auto !important;
                max-height: none !important;
                /* Override any flex or grid positioning that might interfere */
                flex: none !important;
                align-self: auto !important;
                justify-self: auto !important;
            }
        }

        #waypoint-header {
            display: flex;
            align-items: center;
            gap: 10px;
            width: fit-content;
        }

                #waypoint-title {
            font-size: 24px;
            margin: 0;
            flex: 0 1 auto;
            line-height: 1.2;
        }

                #expand-btn {
            background: transparent;
            color: white;
            border: none;
            padding: 0;
            cursor: pointer;
            font-size: 14px;
            font-weight: normal;
            transition: opacity 0.2s ease;
            flex-shrink: 0;
            opacity: 0.7;
        }

        #expand-btn:hover {
            opacity: 1;
        }

        #waypoint-content {
            margin-top: 10px;
        }

        #waypoint-description {
            font-size: 16px;
            line-height: 1.4;
            margin: 0;
        }

                /* Mobile specific adjustments */
        @media (max-width: 768px) {
            #tour-controls {
                gap: 6px;
                padding: 0 5px;
            }

            #tour-controls button {
                padding: 12px 14px;
                font-size: 18px;
                min-width: 46px;
                min-height: 46px;
                flex: 0 1 auto;
            }

            #waypoint-dropdown {
                width: 32px !important;
                padding: 12px 4px !important;
                font-size: 14px !important;
            }

            #speed-dropdown {
                width: 38px !important;
                padding: 12px 4px !important;
                font-size: 14px !important;
            }

                        #waypoint-info {
                padding: 20px 15px;
                margin: 10px auto !important;
                max-width: calc(100vw - 20px);
                position: relative !important;
                left: auto !important;
                right: auto !important;
                top: auto !important;
                bottom: auto !important;
                width: fit-content !important;
            }

            #waypoint-info.collapsed #waypoint-content {
                display: none;
            }

            #waypoint-info.expanded {
                position: fixed !important;
                top: 10px !important;
                left: 10px !important;
                right: 10px !important;
                bottom: auto !important;
                max-height: 70vh;
                overflow-y: auto;
                z-index: 1000;
                background: rgba(0, 0, 0, 0.9);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
                width: auto !important;
                margin: 0 !important;
            }

                        #waypoint-title {
                font-size: 28px;
                font-weight: bold;
            }

            #waypoint-description {
                font-size: 16px;
            }

            #expand-btn {
                font-size: 16px;
            }
        }

        /* Very narrow screens (iPhone SE, etc.) */
        @media (max-width: 400px) {
            #tour-controls {
                gap: 4px;
                padding: 0 3px;
            }

            #tour-controls button {
                padding: 10px 12px;
                font-size: 16px;
                min-width: 40px;
                min-height: 40px;
                flex: 1 1 auto;
                max-width: 60px;
            }

            #waypoint-dropdown {
                width: 28px !important;
                padding: 10px 2px !important;
                font-size: 12px !important;
                flex: 0 0 28px;
            }

            #speed-dropdown {
                width: 32px !important;
                padding: 10px 2px !important;
                font-size: 12px !important;
                flex: 0 0 32px;
            }

            #progress-container {
                margin: 0 3px 8px 3px;
                padding: 6px 10px;
            }

                        #waypoint-info {
                margin: 10px auto !important;
                padding: 18px 12px;
                max-width: calc(100vw - 15px);
                position: relative !important;
                left: auto !important;
                right: auto !important;
                top: auto !important;
                bottom: auto !important;
                width: fit-content !important;
            }

            #waypoint-info.expanded {
                top: 5px !important;
                left: 5px !important;
                right: 5px !important;
                max-height: 75vh;
                padding: 15px;
                margin: 0 !important;
            }

                        #waypoint-title {
                font-size: 24px;
                font-weight: bold;
            }

            #waypoint-description {
                font-size: 15px;
            }

            #expand-btn {
                font-size: 14px;
            }
        }

        /* Countdown Timer */
        #countdown-timer {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        #countdown-value {
            color: #2962FF;
            font-size: 16px;
        }

        @media (max-width: 768px) {
            #countdown-timer {
                bottom: 10px;
                right: 10px;
                font-size: 12px;
                padding: 6px 10px;
            }

            #countdown-value {
                font-size: 14px;
            }
        }
    </style>
</head>

<body>
    <div id="aladin-lite-div"></div>

    <div id="loading-div">Loading ACES Star Formation Tour... Please wait.</div>

    <div id="waypoint-info">
        <div id="waypoint-header">
            <button id="expand-btn" title="Expand/Collapse Info">‚ñ∂</button>
            <h2 id="waypoint-title">Welcome to the ACES Central Molecular Zone Tour</h2>
        </div>
        <div id="waypoint-content">
            <p id="waypoint-description">
            This is a brief tour through the ACES view of the Central Molecular Zone.  Click "Start Tour" to begin.
            </p>
        </div>
    </div>

    <div id="progress-container">
        <div id="progress-bar">
            <div id="progress"></div>
        </div>
        <span id="current-waypoint">0</span>
    </div>

    <div id="tour-controls">
        <button id="prev-btn" title="Previous">‚Äπ</button>
        <button id="next-btn" title="Next">‚Ä∫</button>
        <button id="start-btn" title="Start/Play Tour">‚ñ∂</button>
        <button id="reset-btn" title="Reset">‚ü≤</button>
        <button id="share-btn" title="Copy shareable link to current waypoint">üîó</button>
        <select id="waypoint-dropdown" title="Jump to waypoint"
            style="background-color: #2962FF; color: white; border: none; padding: 12px 6px; border-radius: 8px; margin: 0 3px; cursor: pointer; font-size: 16px; position: relative; z-index: 120; width: 36px; text-align: center; -webkit-appearance: none; -moz-appearance: none; appearance: none;">
            <option value="">‚â´</option>
        </select>
        <select id="speed-dropdown" title="Tour speed: 1√ó = normal, 2√ó = double speed, 4√ó = quadruple speed"
            style="background-color: #2962FF; color: white; border: none; padding: 12px 6px; border-radius: 8px; margin: 0 3px; cursor: pointer; font-size: 16px; position: relative; z-index: 120; width: 42px; text-align: center; -webkit-appearance: none; -moz-appearance: none; appearance: none;">
            <option value="1" selected>1√ó</option>
            <option value="2">2√ó</option>
            <option value="4">4√ó</option>
        </select>
    </div>

    <div id="countdown-timer" style="display: none;">
        <span id="countdown-text">Next in: </span>
        <span id="countdown-value">5</span>
    </div>

    <script>
        let aladin;
        let currentWaypoint = 0;
        let isPlaying = false;
        let waypointTimeout;
        let loopTour = true; // Flag to enable continuous looping (default on)
        let interruptAnimation = false; // Flag to interrupt ongoing animations
        let currentImageLayer = null; // Track the most recently added image layer
        let isInfoExpanded = false; // Track info panel state
        let countdownInterval = null; // Track countdown timer
        let countdownEndTime = null; // When the countdown should end

        // Layer management system to avoid reloading layers
        let layerCache = new Map(); // URL -> layer object mapping
        let layerOrder = []; // Track layer order for bringing to front
        let layerCounter = 0; // Counter for generating unique layer names
        let stickyUrl = null; // Track sticky layer that should persist across waypoints

        // Speed control system
        let speedMultiplier = 1; // 1 = normal, 2 = 2x speed, 4 = 4x speed

        // Root URL configuration based on environment
        let rootUrl;
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            rootUrl = './';
            console.log('Running on localhost, using relative paths');
        } else {
            rootUrl = 'https://keflavich.github.io/avm_images/';
            console.log('Running on internet, using GitHub Pages URL');
        }

        // Function to construct full URL for image layers
        function getImageUrl(relativePath) {
            if (!relativePath) return relativePath;
            // If it's already a full URL, return as-is
            if (relativePath.startsWith('http://') || relativePath.startsWith('https://')) {
                return relativePath;
            }
            return rootUrl + relativePath;
        }

        // URL anchor management for shareable waypoints
        function titleToAnchor(title) {
            if (!title) return '';
            return title.toLowerCase()
                       .replace(/[^a-z0-9\s-]/g, '') // Remove special chars except spaces and hyphens
                       .replace(/\s+/g, '-') // Replace spaces with hyphens
                       .replace(/-+/g, '-') // Replace multiple hyphens with single
                       .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens
        }

        function updateUrlHash() {
            if (currentWaypoint >= 0 && currentWaypoint < waypoints.length) {
                const anchor = titleToAnchor(waypoints[currentWaypoint].title);
                if (anchor) {
                    const newHash = '#' + anchor;
                    if (window.location.hash !== newHash) {
                        window.history.pushState(null, null, newHash);
                        console.log('Updated URL hash to:', newHash);
                    }
                }
            }
        }

        function getWaypointFromHash() {
            const hash = window.location.hash.slice(1); // Remove the '#'
            if (!hash) return -1;

            for (let i = 0; i < waypoints.length; i++) {
                if (titleToAnchor(waypoints[i].title) === hash) {
                    console.log('Found waypoint for hash:', hash, 'at index:', i);
                    return i;
                }
            }
            console.log('No waypoint found for hash:', hash);
            return -1;
        }

        function handleHashChange() {
            const targetWaypoint = getWaypointFromHash();
            if (targetWaypoint >= 0 && targetWaypoint !== currentWaypoint) {
                console.log('Hash changed, jumping to waypoint:', targetWaypoint);
                isPlaying = false;
                clearTimeout(waypointTimeout);
                stopCountdown();
                updatePlayPauseButton();
                jumpToWaypointWithLayers(targetWaypoint);
            }
        }

        // Function to get or create a layer, reusing existing ones
        function getOrCreateLayer(url) {
            if (!url) return null;

            // Check if we already have this layer cached
            if (layerCache.has(url)) {
                console.log("Reusing existing layer for URL:", url);
                return layerCache.get(url);
            }

            // Create a new layer with a unique name
            layerCounter++;
            const layerName = `layer_${layerCounter}`;

            console.log("Creating new layer for URL:", url, "with name:", layerName);

            let layer;
            if (url.endsWith('.jpg')) {
                // For JPG files, we can't use overlay layers, so handle differently
                aladin.displayJPG(url);
                // Store a reference but note it's not a true layer object
                layerCache.set(url, { isJPG: true, url: url });
                return layerCache.get(url);
            } else {
                // Create an overlay image layer with a unique name
                const survey = aladin.newImageSurvey(url);
                layer = survey;
                aladin.setOverlayImageLayer(survey, layerName);

                // Cache the layer
                layerCache.set(url, { layer: layer, name: layerName, url: url });
                layerOrder.push(url);

                return layerCache.get(url);
            }
        }

        // Function to bring a layer to the foreground
        function bringLayerToFront(url) {
            if (!url || !layerCache.has(url)) return;

            const cachedLayer = layerCache.get(url);

            if (cachedLayer.isJPG) {
                // For JPG layers, we need to redisplay them
                console.log("Bringing JPG layer to front:", url);
                aladin.displayJPG(url);
                return cachedLayer;
            }

                        // For regular layers, make sure it's visible and has full opacity
            if (cachedLayer.layer) {
                console.log("Bringing layer to front:", url, "name:", cachedLayer.name);
                cachedLayer.layer.setOpacity(1.0);

                // Update the layer order
                const index = layerOrder.indexOf(url);
                if (index > -1) {
                    layerOrder.splice(index, 1);
                }
                layerOrder.push(url);

                // Set as current image layer
                currentImageLayer = cachedLayer.layer;

                // Debug: show cache status
                if (console.log) {
                    showLayerCacheStatus();
                }

                return cachedLayer;
            }
        }

                // Function to hide other layers, keeping the two most recent visible
        function hideOtherLayers(currentUrl, waypoint = null) {
            // Determine which layer should be the background layer
            let backgroundUrl = null;

            if (waypoint && waypoint.fade_layer) {
                // Use the specified fade_layer
                backgroundUrl = waypoint.fade_layer;
                console.log("Showing layers - Current:", currentUrl, "Fade layer:", backgroundUrl);
            } else {
                // Use the previous layer in order
                const currentIndex = layerOrder.indexOf(currentUrl);
                backgroundUrl = currentIndex > 0 ? layerOrder[currentIndex - 1] : null;
                console.log("Showing layers - Current:", currentUrl, "Previous:", backgroundUrl);
            }

            // Get fade out duration from waypoint or use default
            const fadeOutDuration = waypoint ? getAdjustedWaypointTime(waypoint, 'fade_out_time', 0.5) : 0.5;

            layerCache.forEach((cachedLayer, url) => {
                if (cachedLayer.isJPG || !cachedLayer.layer) return;

                if (url === currentUrl) {
                    // Current layer: full opacity
                    cachedLayer.layer.setOpacity(1.0);
                } else if (url === stickyUrl) {
                    cachedLayer.layer.setOpacity(1.0);
                } else if (url === backgroundUrl) {
                    // Background layer (either previous or specified fade_layer): keep visible
                    cachedLayer.layer.setOpacity(1.0);
                } else {
                    // All other layers: fade out smoothly instead of hiding immediately
                    const currentOpacity = cachedLayer.layer.getAlpha();
                    if (currentOpacity > 0) {
                        console.log("Fading out layer:", url, "from opacity", currentOpacity, "over", fadeOutDuration, "seconds");
                        animateLayerOpacity(cachedLayer.layer, currentOpacity, 0, fadeOutDuration, null);
                    }
                }
            });
        }

        // Function to clear layer cache (useful for reset)
        function clearLayerCache() {
            console.log("Clearing layer cache");
            layerCache.clear();
            layerOrder = [];
            layerCounter = 0;
            currentImageLayer = null;
            stickyUrl = null;
        }

        // Function to get current active layer for animations
        function getCurrentActiveLayer() {
            // Try to find the most recently activated layer
            if (layerOrder.length > 0) {
                const lastUrl = layerOrder[layerOrder.length - 1];
                const cachedLayer = layerCache.get(lastUrl);
                if (cachedLayer && !cachedLayer.isJPG && cachedLayer.layer) {
                    return cachedLayer.layer;
                }
            }
            return currentImageLayer; // Fallback to old system
        }

        // Debug function to show layer cache status
        function showLayerCacheStatus() {
            console.log("=== Layer Cache Status ===");
            console.log("Total cached layers:", layerCache.size);
            console.log("Layer order:", layerOrder);
            layerCache.forEach((cachedLayer, url) => {
                const type = cachedLayer.isJPG ? "JPG" : "HiPS";
                const opacity = cachedLayer.layer ? cachedLayer.layer.getAlpha() : "N/A";
                console.log(`- ${url}: ${type}, opacity: ${opacity}`);
            });
            console.log("========================");
        }

        // Helper functions for speed-adjusted timing
        function getAdjustedTime(timeInSeconds) {
            return timeInSeconds / speedMultiplier;
        }

        function getAdjustedTimeMs(timeInMs) {
            return timeInMs / speedMultiplier;
        }

        function getAdjustedWaypointTime(waypoint, timeProperty, defaultValue = 2) {
            const baseTime = waypoint[timeProperty] || defaultValue;
            const adjustedTime = getAdjustedTime(baseTime);
            if (speedMultiplier !== 1) {
                console.log(`Speed adjustment: ${timeProperty} ${baseTime}s -> ${adjustedTime.toFixed(2)}s (${speedMultiplier}x speed)`);
            }
            return adjustedTime;
        }

        function getAdjustedWaypointTimeMs(waypoint, timeProperty, defaultValue = 2000) {
            const baseTime = waypoint[timeProperty] || defaultValue;
            const adjustedTime = getAdjustedTimeMs(baseTime);
            if (speedMultiplier !== 1) {
                console.log(`Speed adjustment: ${timeProperty} ${baseTime}ms -> ${adjustedTime.toFixed(0)}ms (${speedMultiplier}x speed)`);
            }
            return adjustedTime;
        }

        // Initialize mobile info panel
        function initializeMobileInfoPanel() {
            const infoPanel = document.getElementById('waypoint-info');
            const expandBtn = document.getElementById('expand-btn');

            // Set initial state based on screen size
            if (window.innerWidth <= 768) {
                infoPanel.classList.add('collapsed');
                isInfoExpanded = false;
                expandBtn.innerHTML = '‚ñ∂';
                expandBtn.title = 'Expand Info';
            } else {
                infoPanel.classList.remove('collapsed', 'expanded');
                expandBtn.style.display = 'none';
            }

            // Add expand button event listener
            expandBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                toggleInfoPanel();
            });

                        // Handle window resize
            window.addEventListener('resize', function() {
                if (window.innerWidth > 768) {
                    // Desktop view - hide expand button and reset state
                    infoPanel.classList.remove('collapsed', 'expanded');
                    expandBtn.style.display = 'none';
                    isInfoExpanded = false;
                } else {
                    // Mobile view - show expand button and set collapsed state
                    expandBtn.style.display = 'block';
                    if (!isInfoExpanded) {
                        infoPanel.classList.add('collapsed');
                        infoPanel.classList.remove('expanded');
                    }
                }
            });
        }

        // Toggle info panel expand/collapse
        function toggleInfoPanel() {
            const infoPanel = document.getElementById('waypoint-info');
            const expandBtn = document.getElementById('expand-btn');

            if (isInfoExpanded) {
                // Collapse
                infoPanel.classList.remove('expanded');
                infoPanel.classList.add('collapsed');
                expandBtn.innerHTML = '‚ñ∂';
                expandBtn.title = 'Expand Info';
                isInfoExpanded = false;
            } else {
                // Expand
                infoPanel.classList.remove('collapsed');
                infoPanel.classList.add('expanded');
                expandBtn.innerHTML = '‚ñº';
                expandBtn.title = 'Collapse Info';
                isInfoExpanded = true;
            }
        }

        // Countdown timer functions
        function startCountdown(durationMs) {
            if (!isPlaying) return;

            stopCountdown(); // Clear any existing countdown

            countdownEndTime = Date.now() + durationMs;
            const countdownTimer = document.getElementById('countdown-timer');
            const countdownValue = document.getElementById('countdown-value');

            countdownTimer.style.display = 'block';

            function updateCountdown() {
                if (!isPlaying || !countdownEndTime) {
                    stopCountdown();
                    return;
                }

                const timeLeft = countdownEndTime - Date.now();
                if (timeLeft <= 0) {
                    stopCountdown();
                    return;
                }

                const secondsLeft = Math.ceil(timeLeft / 1000);
                countdownValue.textContent = secondsLeft;
            }

            // Update immediately and then every 100ms for smooth countdown
            updateCountdown();
            countdownInterval = setInterval(updateCountdown, 100);
        }

        function stopCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            countdownEndTime = null;
            document.getElementById('countdown-timer').style.display = 'none';
        }

        // Function to advance to the next waypoint
        function autoAdvance() {
            if (!isPlaying) return;
            if (currentWaypoint < waypoints.length - 1) {
                goToWaypoint(currentWaypoint + 1);
            } else if (loopTour) {
                goToWaypoint(0);
            } else {
                isPlaying = false;
                return;
            }
            // Note: timeout is now set in goToWaypoint() after animation completes
        }


        // Define waypoints for the tour
        const waypoints = [
            {
                ra: 266.416667,
                dec: -29.008333,
                fov: 3.0,
                transition_fov: 3.0,
                transition_time: 2,
                zoom_out_time: 0,
                zoom_in_time: 2,
                title: "The CMZ",
                description: "The Central Molecular Zone seen with MEERKAT and Spitzer.  Color composite by Ashley Barnes.",
                url: getImageUrl("rgb_final_uncropped_hips"),
                pause_time: 5000  // Brief introduction
            },
            {
                ra: 266.416667,
                dec: -29.008333,
                fov: 0.8,
                transition_fov: 3.0,
                transition_time: 3,
                zoom_out_time: 2,
                zoom_in_time: 3,
                title: "ACES",
                description: "The ALMA Central Molecular Zone survey (ACES) combined with the Green Bank Telescope's MUSTANG survey in the Galactic Center.  This is the highest-resolution millimeter image produced of the Galactic Center.",
                url: getImageUrl("MUSTANG_12m_feather_noaxes_hips/"),
                is_sticky: true,
                //fade_enabled: true,
                fade_out_time: 1.5,
                fade_delay: 0.5,
                fade_in_time: 1.5,
                pause_time: 2000  // Short pause after fade
            },
            {
                ra: 266.835223,
                dec: -28.3958813,
                fov: 0.1,
                transition_fov: 0.8,
                transition_time: 3,
                zoom_out_time: 2,
                zoom_in_time: 3,
                title: "Sgr B2 with ALMA",
                description: "The Sgr B2 cloud is our Galaxy's most massive and active star-forming region.  It contains several high-mass protoclusters, Sgr B2 N and M, and a third that's a bit smaller, S. \n  This image shows the medium-resolution view of Sgr B2 with ALMA from Ginsburg+ 2018. ",
                url: getImageUrl("feathered_MGPS_ALMATCTE7m_hips/"),
                //fade_enabled: true,
                fade_out_time: 1.5,
                fade_delay: 0.5,
                fade_in_time: 1.5,
                pause_time: 3000  // Medium pause after fade
            },
            {
                ra: 266.83311023,
                dec: -28.37178279,
                fov: 0.006,
                transition_fov: 1,
                transition_time: 5,
                zoom_out_time: 3,
                zoom_in_time: 5,
                title: "Sgr B2N",
                description: "Sagittarius B2 North is the most massive site of ongoing star formation in the Milky Way.  Within a region less than a tenth of a parsec across, thousands of solar masses of gas are flowing into a central massive-star-forming protocluster birthing several proto-O-stars within only a few thousand astronomical units.  \n Data by Nazar Budaiev.",
                url: getImageUrl("GINSBURG_P_SgrB2N_RGB/"),
                fade_layer: getImageUrl("feathered_MGPS_ALMATCTE7m_hips/"),
                //fade_enabled: true,
                fade_out_time: 2,
                fade_delay: 0.5,
                fade_in_time: 2,
                pause_time: 4000  // Longer pause for detailed view
            },
            {
                ra: 266.833992,
                dec: -28.38459,
                fov: 0.006,
                transition_fov: 0.012,
                transition_time: 5,
                zoom_out_time: 3,
                zoom_in_time: 5,
                title: "Sgr B2M",
                description: "Sgr B2M is the most massive embedded star cluster in the Galactic Center.  The image shows several HII regions, sites where massive stars have ionized their surroundings, within a tiny volume.   \n Data by Nazar Budaiev.",
                url: getImageUrl("GINSBURG_P_SgrB2M_RGB/"),
                fade_layer: getImageUrl("feathered_MGPS_ALMATCTE7m_hips/"),
                //fade_enabled: true,
                fade_out_time: 2,
                fade_delay: 0.5,
                fade_in_time: 2,
                pause_time: 2000,
            },
            // {
            //     ra: 266.833992,
            //     dec: -28.38459,
            //     fov: 0.006,
            //     transition_fov: 0.012,
            //     transition_time: 5,
            //     zoom_out_time: 3,
            //     zoom_in_time: 5,
            //     url: getImageUrl("SgrB2_RGB_480-405-187_scaled_hips/"),
            //     fade_layer: getImageUrl("feathered_MGPS_ALMATCTE7m_hips/"),
            //     title: "Sgr B2M JWST",
            //     description: "The Sgr B2 cloud seen with JWST.  This is a composite of the 405, 356, and 200 micron bands.  \n Data by Nazar Budaiev & Adam Ginsburg.",
            //     pause_time: 1000
            // },
            {
                ra: 266.835223,
                dec: -28.3958813,
                fov: 0.1,
                transition_fov: 0.1,
                transition_time: 5,
                zoom_out_time: 3,
                zoom_in_time: 5,
                url: getImageUrl("SgrB2_RGB_480-405-187_scaled_hips/"),
                fade_layer: getImageUrl("feathered_MGPS_ALMATCTE7m_hips/"),
                title: "Sgr B2 JWST",
                description: "The Sgr B2 cloud seen with JWST.  This is a composite of the 4.80, 4.05, and 1.87 micron bands.  \n Data by Nazar Budaiev & Adam Ginsburg.",
                //fade_enabled: true,
                fade_out_time: 1,
                fade_delay: 0.5,
                fade_in_time: 1,
            },
            {
                ra: 266.833327,
                dec: -28.3797941,
                fov: 0.05,
                transition_fov: 0.05,
                transition_time: 5,
                zoom_out_time: 1,
                zoom_in_time: 1,
                url: getImageUrl("SgrB2_RGB_2550-1280-770_hips/"),
                fade_layer: getImageUrl("SgrB2_RGB_480-405-187_scaled_hips/"),
                title: "Sgr B2 - MIRI",
                description: "The Sgr B2 cloud seen with JWST MIRI.  This is a composite of the 25.5, 12.8, and 7.7 micron bands.  \n Data by Nazar Budaiev & Adam Ginsburg.",
                //fade_enabled: true,
                fade_out_time: 1,
                fade_delay: 0.5,
                fade_in_time: 1,
                pause_time: 5000,
            },
            {
                ra: 266.541320,
                dec: -28.7088928,
                fov: 0.12,
                transition_fov: 0.5,
                transition_time: 5,
                zoom_out_time: 3,
                zoom_in_time: 5,
                url: getImageUrl("BrickJWST_1182p2221_405_356_200_hips/"),
                fade_layer: getImageUrl("MUSTANG_12m_feather_noaxes_hips/"),
                title: "Brick JWST - 200 356 405",
                description: "The Brick JWST image of the Galactic Center.  This is a composite of the 4.05, 3.56, and 2.00 micron bands.  \n Ginsburg et al 2023 & project 1182.",
                //fade_enabled: true,
                fade_out_time: 1,
                fade_delay: 0.5,
                fade_in_time: 1,
                pause_time: 5000
            },
            {
                ra: 266.541320,
                dec: -28.7088928,
                fov: 0.12,
                transition_fov: 0.12,
                transition_time: 1,
                zoom_out_time: 1,
                zoom_in_time: 1,
                url: getImageUrl("BrickJWST_merged_longwave_narrowband_withstars_hips/"),
                fade_layer: getImageUrl("BrickJWST_1182p2221_405_356_200_hips/"),
                title: "Brick JWST - 410 466",
                description: "The Brick JWST image of the Galactic Center.  This is a composite of the 4.10 and 4.66 micron bands including stars.  \n Ginsburg et al 2023.",
                //fade_enabled: true,
                fade_out_time: 1,
                fade_delay: 0.5,
                fade_in_time: 1,
                pause_time: 5000
            },
            {
                ra: 266.541320,
                dec: -28.7088928,
                fov: 0.12,
                transition_fov: 0.12,
                transition_time: 1,
                zoom_out_time: 1,
                zoom_in_time: 1,
                url: getImageUrl("BrickJWST_merged_longwave_narrowband_hips/"),
                fade_layer: getImageUrl("BrickJWST_merged_longwave_narrowband_withstars_hips/"),
                title: "Brick JWST - 410 466 starless",
                description: "The Brick JWST image of the Galactic Center.  This is a composite of the 4.10 and 4.66 micron bands with stars removed.  \n Ginsburg et al 2023.",
                //fade_enabled: true,
                fade_out_time: 1,
                fade_delay: 0.5,
                fade_in_time: 1,
                pause_time: 5000
            },
        ];

        // Initialize Aladin once the page is loaded
        document.addEventListener('DOMContentLoaded', function () {
            console.log('Document loaded, waiting for A.init to complete');

                        // Make controls draggable (waypoint-info is static)
            makeDraggable(document.getElementById('progress-container'));
            makeDraggable(document.getElementById('tour-controls'));

            // Initialize mobile info panel state
            initializeMobileInfoPanel();

            // Prevent dropdowns from being affected by draggable behavior
            const waypointDropdown = document.getElementById('waypoint-dropdown');
            const speedDropdown = document.getElementById('speed-dropdown');

            [waypointDropdown, speedDropdown].forEach(dropdown => {
                dropdown.addEventListener('mousedown', function (e) {
                    e.stopPropagation(); // Stop the event from bubbling up
                });
                dropdown.addEventListener('click', function (e) {
                    e.stopPropagation(); // Stop the event from bubbling up
                });
                dropdown.addEventListener('focus', function (e) {
                    e.stopPropagation(); // Stop the event from bubbling up
                });
            });

            // Wait for A.init promise to complete (required for v3 API)
            A.init.then(() => {
                console.log('A.init completed, creating Aladin instance');

                aladin = A.aladin('#aladin-lite-div', {
                    survey: getImageUrl('rgb_final_uncropped_hips/'),
                    // survey: "IPAC/P/GLIMPSE360",
                    //;'"P/2MASS/color",
                    fov: waypoints[0].fov,
                    target: waypoints[0].ra + ' ' + waypoints[0].dec,
                    cooFrame: 'GAL',
                    showReticle: false,
                    showZoomControl: true,
                    showFullscreenControl: true,
                    showLayersControl: true,
                    showGotoControl: true,
                    showFrame: true,
                    showCooGrid: false,
                    showSimbadPointerControl: true,
                    showSettingsControl: true,
                    showShareControl: true,
                });


                // Initialize the first layer using our caching system
                const initialCachedLayer = getOrCreateLayer(getImageUrl('rgb_final_uncropped_hips/'));
                bringLayerToFront(getImageUrl('rgb_final_uncropped_hips/'));

                // Also cache the first waypoint's layer if it's different
                if (waypoints[0].url && waypoints[0].url !== 'rgb_final_uncropped_hips/') {
                    getOrCreateLayer(waypoints[0].url);
                }

                // Hide loading message
                document.getElementById('loading-div').style.display = 'none';

                // Populate waypoint dropdown
                populateWaypointDropdown();

                // Check for URL hash and jump to that waypoint if present
                const hashWaypoint = getWaypointFromHash();
                if (hashWaypoint >= 0) {
                    console.log('Found URL hash, jumping to waypoint:', hashWaypoint);
                    updateWaypointInfo();
                    updateProgressBar();
                    jumpToWaypointWithLayers(hashWaypoint);
                } else {
                    updateWaypointInfo();
                    updateProgressBar();
                    goToWaypointFast(0);
                }

                // Set up browser back/forward navigation handling
                window.addEventListener('popstate', handleHashChange);
                window.addEventListener('hashchange', handleHashChange);

                // Set up event listeners for the buttons
                document.getElementById('prev-btn').addEventListener('click', function () {
                    isPlaying = false;
                    clearTimeout(waypointTimeout);
                    stopCountdown();
                    updatePlayPauseButton();
                    goToWaypoint(currentWaypoint - 1);
                });

                // document.getElementById('next-btn-fast').addEventListener('click', function() {
                //     console.log("Clicked next-btn-fast.  Current waypoint: ", currentWaypoint);
                //     if (currentWaypoint === waypoints.length - 1) {
                //         // If at the last waypoint, reset to the beginning
                //         goToWaypointFast(0);
                //         return;
                //     } else {
                //         isPlaying = false;
                //         goToWaypointFast(currentWaypoint + 1);
                //     }
                // });

                document.getElementById('next-btn').addEventListener('click', function () {
                    if (currentWaypoint === waypoints.length - 1) {
                        // If at the last waypoint, reset to the beginning
                        isPlaying = false;
                        clearTimeout(waypointTimeout);
                        stopCountdown();
                        updatePlayPauseButton();
                        goToWaypoint(0);
                        return;
                    }

                    // Just advance to next waypoint without auto-playing
                    isPlaying = false;
                    clearTimeout(waypointTimeout);
                    stopCountdown();
                    updatePlayPauseButton();
                    goToWaypoint(currentWaypoint + 1);
                });

                document.getElementById('start-btn').addEventListener('click', function () {
                    if (isPlaying) {
                        // Pause the tour
                        pauseTour();
                    } else {
                        // Start/resume the tour
                        startTour();
                    }
                });

                document.getElementById('reset-btn').addEventListener('click', function () {
                    isPlaying = false;
                    clearTimeout(waypointTimeout);
                    stopCountdown();
                    updatePlayPauseButton();

                    // Reset speed multiplier to normal speed
                    speedMultiplier = 1;
                    document.getElementById('speed-dropdown').value = "1";
                    console.log("Speed reset to normal (1√ó)");

                    goToWaypoint(0);
                });

                document.getElementById('share-btn').addEventListener('click', function () {
                    // Copy current URL to clipboard
                    const shareableUrl = window.location.href;
                    navigator.clipboard.writeText(shareableUrl).then(function() {
                        // Show brief feedback
                        const btn = document.getElementById('share-btn');
                        const originalTitle = btn.title;
                        const originalContent = btn.innerHTML;

                        btn.title = 'Link copied!';
                        btn.innerHTML = '‚úì';
                        btn.style.color = '#4CAF50';

                        setTimeout(function() {
                            btn.title = originalTitle;
                            btn.innerHTML = originalContent;
                            btn.style.color = '';
                        }, 2000);

                        console.log('Copied shareable URL to clipboard:', shareableUrl);
                    }).catch(function(err) {
                        console.error('Failed to copy URL to clipboard:', err);
                        // Fallback: select the URL text
                        prompt('Copy this shareable link:', shareableUrl);
                    });
                });



                // Set up waypoint dropdown event listener
                document.getElementById('waypoint-dropdown').addEventListener('change', function () {
                    const selectedIndex = parseInt(this.value);
                    if (!isNaN(selectedIndex)) {
                        isPlaying = false;
                        clearTimeout(waypointTimeout);
                        stopCountdown();
                        updatePlayPauseButton();
                        jumpToWaypointWithLayers(selectedIndex);
                        // Reset dropdown to default after selection
                        this.selectedIndex = 0;
                    }
                });

                // Set up speed dropdown event listener
                document.getElementById('speed-dropdown').addEventListener('change', function () {
                    const selectedSpeed = parseFloat(this.value);
                    if (!isNaN(selectedSpeed) && selectedSpeed > 0) {
                        speedMultiplier = selectedSpeed;
                        console.log("Speed multiplier set to:", speedMultiplier);

                        // If currently playing, restart countdown with new timing
                        if (isPlaying && countdownEndTime) {
                            const remainingTime = countdownEndTime - Date.now();
                            if (remainingTime > 0) {
                                // Adjust remaining time based on new speed
                                const adjustedTime = remainingTime / speedMultiplier;
                                startCountdown(adjustedTime);
                            }
                        }
                    }
                });
            }).catch(err => {
                console.error('Failed to initialize Aladin:', err);
                document.getElementById('loading-div').textContent = 'Error loading Aladin. Please refresh the page.';
            });
        });

        // Function to update the waypoint information
        function updateWaypointInfo() {
            document.getElementById('waypoint-title').innerText = waypoints[currentWaypoint].title;
            document.getElementById('waypoint-description').innerText = waypoints[currentWaypoint].description;
            document.getElementById('current-waypoint').innerText = (currentWaypoint + 1) + '/' + waypoints.length;

            // Update URL hash for shareable links
            updateUrlHash();

            // Update button states
            updateButtonStates();
        }

        // Function to update button states
        function updateButtonStates() {
            const prevBtn = document.getElementById('prev-btn');

            // Disable previous button at first waypoint
            if (currentWaypoint === 0) {
                prevBtn.disabled = true;
                prevBtn.title = 'Previous (unavailable)';
            } else {
                prevBtn.disabled = false;
                prevBtn.title = 'Previous';
            }

            // Update next button text to show the next region name
            updateNextButtonText();

            // Update play/pause button
            updatePlayPauseButton();
        }

        // Function to update play/pause button appearance
        function updatePlayPauseButton() {
            const playBtn = document.getElementById('start-btn');
            if (isPlaying) {
                playBtn.innerHTML = '‚è∏';
                playBtn.title = 'Pause Tour';
            } else {
                playBtn.innerHTML = '‚ñ∂';
                playBtn.title = 'Play/Resume Tour';
            }
        }

                // Function to start/resume the tour
        function startTour() {
            isPlaying = true;
            interruptAnimation = false;  // Reset interrupt flag for new animations
            updatePlayPauseButton();

            // If starting from waypoint 0, immediately go to waypoint 1 to start the tour
            if (currentWaypoint === 0) {
                goToWaypoint(1);
            } else {
                goToWaypoint(currentWaypoint);
            }
        }

        // Function to pause the tour
        function pauseTour() {
            isPlaying = false;
            interruptAnimation = true;  // Halt any ongoing animations immediately
            clearTimeout(waypointTimeout);
            stopCountdown();
            updatePlayPauseButton();
        }

        // Function to populate the waypoint dropdown
        function populateWaypointDropdown() {
            const dropdown = document.getElementById('waypoint-dropdown');
            // Clear existing options except the first one
            while (dropdown.options.length > 1) {
                dropdown.remove(1);
            }

            // Add all waypoints
            waypoints.forEach((waypoint, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.text = `${index + 1}. ${waypoint.title}`;
                dropdown.appendChild(option);
            });
        }

        // Function to update the next button text
        function updateNextButtonText() {
            if (currentWaypoint === waypoints.length - 1) {
                // At last waypoint, show restart symbol
                document.getElementById('next-btn').innerHTML = '‚Üª';
                document.getElementById('next-btn').title = 'Restart Tour';
            } else {
                // Show next symbol with tooltip showing next waypoint
                const nextWaypoint = waypoints[currentWaypoint + 1];
                document.getElementById('next-btn').innerHTML = '‚Ä∫';
                document.getElementById('next-btn').title = 'Next: ' + nextWaypoint.title;
            }

            // Highlight the current waypoint in the dropdown
            const dropdown = document.getElementById('waypoint-dropdown');
            Array.from(dropdown.options).forEach((option, index) => {
                if (index > 0 && parseInt(option.value) === currentWaypoint) {
                    option.style.backgroundColor = '#0D47A1';
                } else if (index > 0) {
                    option.style.backgroundColor = '';
                }
            });
        }

        // Function to update the progress bar
        function updateProgressBar() {
            const progress = ((currentWaypoint) / (waypoints.length - 1)) * 100;
            document.getElementById('progress').style.width = progress + '%';
        }

        function goToWaypointFast(index) {
            if (!aladin) {
                console.error('Aladin not initialized yet');
                return;
            }

            // Signal to interrupt any ongoing animation
            interruptAnimation = true;
            clearTimeout(waypointTimeout);

            // Update current waypoint state
            currentWaypoint = index;
            if (currentWaypoint < 0) currentWaypoint = 0;
            if (currentWaypoint >= waypoints.length) currentWaypoint = waypoints.length - 1;

            // Get the waypoint data
            const waypoint = waypoints[currentWaypoint];

            // Update display info
            updateWaypointInfo();
            updateProgressBar();

            // Display image if available
            if (waypoint.url) {
                console.log("Displaying layer (fast): ", waypoint.url);
                const cachedLayer = getOrCreateLayer(waypoint.url);

                // Pre-load fade_layer if specified
                if (waypoint.fade_layer) {
                    console.log("Pre-loading fade layer (fast): ", waypoint.fade_layer);
                    getOrCreateLayer(waypoint.fade_layer);
                }

                bringLayerToFront(waypoint.url);
                // Optionally hide other layers for cleaner display
                hideOtherLayers(waypoint.url, waypoint);
            }

            // Jump directly to the location
            aladin.setFov(waypoint.fov);
            aladin.gotoRaDec(waypoint.ra, waypoint.dec);

            // Reset interrupt flag
            interruptAnimation = false;
        }

        // Function to go to a specific waypoint with animation
        function goToWaypoint(index) {
            if (!aladin) {
                console.error('Aladin not initialized yet');
                return;
            }

            // Reset interrupt flag at the start of a new animation
            interruptAnimation = false;
            clearTimeout(waypointTimeout);

            currentWaypoint = index;
            if (currentWaypoint < 0) currentWaypoint = 0;
            if (currentWaypoint >= waypoints.length) currentWaypoint = waypoints.length - 1;

            const waypoint = waypoints[currentWaypoint];

            // Only update progress bar immediately, delay waypoint info until animation starts
            updateProgressBar();

            // Only stop the tour if we're at the last waypoint and not looping
            if (currentWaypoint === waypoints.length - 1 && !loopTour) {
                isPlaying = false;
                clearTimeout(waypointTimeout);
                updatePlayPauseButton();
            }

            // Calculate total transition time and start countdown immediately if playing
            if (isPlaying && currentWaypoint < waypoints.length - 1) {
                const prevIndex = currentWaypoint > 0 ? currentWaypoint - 1 : 0;
                const prevWaypoint = waypoints[prevIndex];

                // Calculate distance to determine if this is close or distant waypoints
                const distance = Math.sqrt(
                    Math.pow(waypoint.ra - prevWaypoint.ra, 2) +
                    Math.pow(waypoint.dec - prevWaypoint.dec, 2)
                );

                let totalTime = 0;

                if (distance < 0.2) {
                    // Close waypoints: 2s movement + optional fade + pause
                    totalTime = getAdjustedTimeMs(2000); // animateToRaDec time
                } else {
                    // Distant waypoints: zoom out + movement + zoom in + optional fade + pause
                    totalTime = getAdjustedWaypointTimeMs(waypoint, 'zoom_out_time', 2) +
                               getAdjustedWaypointTimeMs(waypoint, 'transition_time', 2) +
                               getAdjustedWaypointTimeMs(waypoint, 'zoom_in_time', 2);
                }

                // Add fade time if enabled
                if (waypoint.fade_enabled) {
                    totalTime += getAdjustedWaypointTimeMs(waypoint, 'fade_out_time', 1.5) +
                                getAdjustedWaypointTimeMs(waypoint, 'fade_delay', 0.5) +
                                getAdjustedWaypointTimeMs(waypoint, 'fade_in_time', 1.5);
                }

                // Add pause time
                totalTime += getAdjustedWaypointTimeMs(waypoint, 'pause_time', 2000);

                // Start countdown for total time
                startCountdown(totalTime);
            } else if (isPlaying && currentWaypoint === waypoints.length - 1 && loopTour) {
                // Handle end of tour countdown
                const endPause = getAdjustedWaypointTimeMs(waypoint, 'end_of_tour_pause',
                                 getAdjustedWaypointTimeMs(waypoint, 'pause_time', 5000));
                startCountdown(endPause);
            }

            const prevIndex = currentWaypoint > 0 ? currentWaypoint - 1 : 0;
            const prevWaypoint = waypoints[prevIndex];

            // Calculate distance between current and previous waypoints
            const distance = Math.sqrt(
                Math.pow(waypoint.ra - prevWaypoint.ra, 2) +
                Math.pow(waypoint.dec - prevWaypoint.dec, 2)
            );

            // If waypoints are close (within 0.1 degrees), skip zoom out step
            if (distance < 0.2) {
                console.log("Close waypoints detected, skipping zoom out step");
                // Update waypoint info right before starting the movement animation
                updateWaypointInfo();

                // Pre-load new layer but don't display yet
                if (waypoints[index].url) {
                    console.log("Pre-loading layer: ", waypoints[index].url);
                    const cachedLayer = getOrCreateLayer(waypoints[index].url);
                    // Immediately hide the newly created layer so it doesn't show during pan/zoom
                    if (cachedLayer && cachedLayer.layer && !cachedLayer.isJPG) {
                        cachedLayer.layer.setOpacity(0.0);
                    }

                    // Pre-load and SHOW fade_layer if specified - this should be visible during pan/zoom
                    if (waypoints[index].fade_layer) {
                        console.log("Pre-loading and showing fade layer: ", waypoints[index].fade_layer);
                        const fadeCachedLayer = getOrCreateLayer(waypoints[index].fade_layer);
                        // Make fade layer visible for the pan/zoom sequence
                        if (fadeCachedLayer && fadeCachedLayer.layer && !fadeCachedLayer.isJPG) {
                            bringLayerToFront(waypoints[index].fade_layer);
                            hideOtherLayers(waypoints[index].fade_layer, waypoints[index]);
                        }
                    }
                }

                // Go directly to the new coordinates
                aladin.animateToRaDec(waypoint.ra, waypoint.dec, getAdjustedTime(2), function () {
                    // Check if animation was interrupted
                    if (interruptAnimation) return;

                    // Then zoom in to target FOV
                    aladin.zoomToFoV(waypoint.fov, getAdjustedWaypointTime(waypoint, 'transition_time', 2), function () {
                        // Check if animation was interrupted
                        if (interruptAnimation) return;

                                                                                // NOW display the new layer after pan and zoom are complete with smooth fade-in
                        if (waypoints[index].url) {
                            console.log("Displaying layer after pan/zoom with fade-in: ", waypoints[index].url);

                            // Update sticky layer if this waypoint is marked as sticky
                            if (waypoints[index].is_sticky) {
                                console.log("Setting sticky layer:", waypoints[index].url);
                                stickyUrl = waypoints[index].url;
                            }

                            const cachedLayer = getOrCreateLayer(waypoints[index].url);
                            if (cachedLayer && cachedLayer.layer && !cachedLayer.isJPG) {
                                // Set up layer visibility and ordering, starting with opacity 0
                                cachedLayer.layer.setOpacity(0.0);

                                // Update layer order
                                const layerIndex = layerOrder.indexOf(waypoints[index].url);
                                if (layerIndex > -1) {
                                    layerOrder.splice(layerIndex, 1);
                                }
                                layerOrder.push(waypoints[index].url);
                                currentImageLayer = cachedLayer.layer;

                                // Hide other layers
                                hideOtherLayers(waypoints[index].url, waypoints[index]);

                                // Animate fade-in using waypoint's fade_in_time (default 0.5s), then continue with waypoint logic
                                const fadeInDuration = getAdjustedWaypointTime(waypoint, 'fade_in_time', 0.5);
                                animateLayerOpacity(cachedLayer.layer, 0, 1, fadeInDuration, function() {
                                    // Check if fade animation is enabled for this waypoint
                                    if (waypoint.fade_enabled) {
                                        animateFade(getAdjustedWaypointTime(waypoint, 'fade_out_time', 1.5),
                                                   getAdjustedWaypointTime(waypoint, 'fade_delay', 0.5),
                                                   getAdjustedWaypointTime(waypoint, 'fade_in_time', 1.5), function() {
                                            // Set up auto-advance timeout using configurable pause time
                                            if (isPlaying) {
                                                if (currentWaypoint === waypoints.length - 1 && loopTour) {
                                                    console.log("End of tour reached, looping back to start");
                                                    clearTimeout(waypointTimeout);
                                                    const endPause = getAdjustedWaypointTimeMs(waypoint, 'end_of_tour_pause',
                                                                     getAdjustedWaypointTimeMs(waypoint, 'pause_time', 3000));
                                                    waypointTimeout = setTimeout(autoAdvance, endPause);
                                                } else if (currentWaypoint < waypoints.length - 1) {
                                                    // Schedule next waypoint using configurable pause time
                                                    clearTimeout(waypointTimeout);
                                                    const pauseTime = getAdjustedWaypointTimeMs(waypoint, 'pause_time', 2000);
                                                    waypointTimeout = setTimeout(autoAdvance, pauseTime);
                                                }
                                            }
                                        });
                                    } else {
                                        // No fade animation, set up auto-advance timeout using configurable pause time
                                        if (isPlaying) {
                                            if (currentWaypoint === waypoints.length - 1 && loopTour) {
                                                console.log("End of tour reached, looping back to start");
                                                clearTimeout(waypointTimeout);
                                                const endPause = getAdjustedWaypointTimeMs(waypoint, 'end_of_tour_pause',
                                                                 getAdjustedWaypointTimeMs(waypoint, 'pause_time', 5000));
                                                waypointTimeout = setTimeout(autoAdvance, endPause);
                                            } else if (currentWaypoint < waypoints.length - 1) {
                                                // Schedule next waypoint using configurable pause time
                                                clearTimeout(waypointTimeout);
                                                const pauseTime = getAdjustedWaypointTimeMs(waypoint, 'pause_time',
                                                             (currentWaypoint === 0 ? 2000 : 8000));
                                                waypointTimeout = setTimeout(autoAdvance, pauseTime);
                                            }
                                        }
                                    }
                                });
                                return; // Exit here, rest handled in callback
                            } else {
                                // Fallback for JPG or other layer types
                                bringLayerToFront(waypoints[index].url);
                                hideOtherLayers(waypoints[index].url, waypoints[index]);
                            }
                        }

                    });
                });
            } else {
                // Multi-step animation with custom FOV animation
                // Pre-load new layer but don't display yet
                if (waypoints[index].url) {
                    console.log("Pre-loading layer: ", waypoints[index].url);
                    const cachedLayer = getOrCreateLayer(waypoints[index].url);
                    // Immediately hide the newly created layer so it doesn't show during pan/zoom
                    if (cachedLayer && cachedLayer.layer && !cachedLayer.isJPG) {
                        cachedLayer.layer.setOpacity(0.0);
                    }

                    // Pre-load and SHOW fade_layer if specified - this should be visible during pan/zoom
                    if (waypoints[index].fade_layer) {
                        console.log("Pre-loading and showing fade layer: ", waypoints[index].fade_layer);
                        const fadeCachedLayer = getOrCreateLayer(waypoints[index].fade_layer);
                        // Make fade layer visible for the pan/zoom sequence
                        if (fadeCachedLayer && fadeCachedLayer.layer && !fadeCachedLayer.isJPG) {
                            bringLayerToFront(waypoints[index].fade_layer);
                            hideOtherLayers(waypoints[index].fade_layer, waypoints[index]);
                        }
                    }
                }

                // Step 1: Zoom out to 5 degrees
                aladin.zoomToFoV(waypoint.transition_fov, getAdjustedWaypointTime(waypoint, 'zoom_out_time', 2), function () {
                    // Check if animation was interrupted
                    if (interruptAnimation) return;

                    // Update waypoint info right before starting the movement animation
                    updateWaypointInfo();
                    // Step 2: Go to the new coordinates
                    aladin.animateToRaDec(waypoint.ra, waypoint.dec, getAdjustedWaypointTime(waypoint, 'transition_time', 2), function () {
                        // Check if animation was interrupted
                        if (interruptAnimation) return;

                        // Step 3: Zoom in to target FOV
                        aladin.zoomToFoV(waypoint.fov, getAdjustedWaypointTime(waypoint, 'zoom_in_time', 2), function () {
                            // Check if animation was interrupted
                            if (interruptAnimation) return;

                                                        // NOW display the new layer after all pan and zoom are complete with smooth fade-in
                            if (waypoints[index].url) {
                                console.log("Displaying layer after pan/zoom with fade-in: ", waypoints[index].url);

                                // Update sticky layer if this waypoint is marked as sticky
                                if (waypoints[index].is_sticky) {
                                    console.log("Setting sticky layer:", waypoints[index].url);
                                    stickyUrl = waypoints[index].url;
                                }

                                const cachedLayer = getOrCreateLayer(waypoints[index].url);
                                if (cachedLayer && cachedLayer.layer && !cachedLayer.isJPG) {
                                    // Set up layer visibility and ordering, starting with opacity 0
                                    cachedLayer.layer.setOpacity(0.0);

                                    // Update layer order
                                    const layerIndex = layerOrder.indexOf(waypoints[index].url);
                                    if (layerIndex > -1) {
                                        layerOrder.splice(layerIndex, 1);
                                    }
                                    layerOrder.push(waypoints[index].url);
                                    currentImageLayer = cachedLayer.layer;

                                    // Hide other layers
                                    hideOtherLayers(waypoints[index].url, waypoints[index]);

                                    // Animate fade-in using waypoint's fade_in_time (default 0.5s), then continue with waypoint logic
                                    const fadeInDuration = getAdjustedWaypointTime(waypoint, 'fade_in_time', 0.5);
                                    animateLayerOpacity(cachedLayer.layer, 0, 1, fadeInDuration, function() {
                                        // Check if fade animation is enabled for this waypoint
                                        if (waypoint.fade_enabled) {
                                            animateFade(getAdjustedWaypointTime(waypoint, 'fade_out_time', 1.5),
                                                       getAdjustedWaypointTime(waypoint, 'fade_delay', 0.5),
                                                       getAdjustedWaypointTime(waypoint, 'fade_in_time', 1.5), function() {
                                                // Set up auto-advance timeout using configurable pause time
                                                if (isPlaying) {
                                                    if (currentWaypoint === waypoints.length - 1 && loopTour) {
                                                        console.log("End of tour reached, looping back to start");
                                                        clearTimeout(waypointTimeout);
                                                        const endPause = getAdjustedWaypointTimeMs(waypoint, 'end_of_tour_pause',
                                                                         getAdjustedWaypointTimeMs(waypoint, 'pause_time', 3000));
                                                        waypointTimeout = setTimeout(autoAdvance, endPause);
                                                    } else if (currentWaypoint < waypoints.length - 1) {
                                                        // Schedule next waypoint using configurable pause time
                                                        clearTimeout(waypointTimeout);
                                                        const pauseTime = getAdjustedWaypointTimeMs(waypoint, 'pause_time', 2000);
                                                        waypointTimeout = setTimeout(autoAdvance, pauseTime);
                                                    }
                                                }
                                            });
                                        } else {
                                            // No fade animation, set up auto-advance timeout using configurable pause time
                                            if (isPlaying) {
                                                if (currentWaypoint === waypoints.length - 1 && loopTour) {
                                                    console.log("End of tour reached, looping back to start");
                                                    clearTimeout(waypointTimeout);
                                                    const endPause = getAdjustedWaypointTimeMs(waypoint, 'end_of_tour_pause',
                                                                     getAdjustedWaypointTimeMs(waypoint, 'pause_time', 5000));
                                                    waypointTimeout = setTimeout(autoAdvance, endPause);
                                                } else if (currentWaypoint < waypoints.length - 1) {
                                                    // Schedule next waypoint using configurable pause time
                                                    clearTimeout(waypointTimeout);
                                                    const pauseTime = getAdjustedWaypointTimeMs(waypoint, 'pause_time', 8000);
                                                    waypointTimeout = setTimeout(autoAdvance, pauseTime);
                                                }
                                            }
                                        }
                                    });
                                    return; // Exit here, rest handled in callback
                                } else {
                                    // Fallback for JPG or other layer types
                                    bringLayerToFront(waypoints[index].url);
                                    hideOtherLayers(waypoints[index].url, waypoints[index]);
                                }
                            }

                        });
                    });
                });
            }
        }

        // Function to jump to a waypoint with all previous layers loaded
        function jumpToWaypointWithLayers(index) {
            if (!aladin) {
                console.error('Aladin not initialized yet');
                return;
            }

            // Signal to interrupt any ongoing animation
            interruptAnimation = true;
            clearTimeout(waypointTimeout);

            // Update current waypoint state
            currentWaypoint = index;
            if (currentWaypoint < 0) currentWaypoint = 0;
            if (currentWaypoint >= waypoints.length) currentWaypoint = waypoints.length - 1;

            // Get the target waypoint data
            const waypoint = waypoints[currentWaypoint];

            // Update display info
            updateWaypointInfo();
            updateProgressBar();

            // Load all image layers from waypoint 0 up to the selected waypoint
            for (let i = 0; i <= currentWaypoint; i++) {
                const wp = waypoints[i];
                if (wp.url) {
                    console.log("Ensuring layer exists for waypoint", i, ":", wp.url);
                    const cachedLayer = getOrCreateLayer(wp.url);

                    // Update sticky layer if this waypoint is marked as sticky
                    if (wp.is_sticky) {
                        console.log("Setting sticky layer from waypoint", i, ":", wp.url);
                        stickyUrl = wp.url;
                    }

                    // Pre-load fade_layer if specified
                    if (wp.fade_layer) {
                        console.log("Pre-loading fade layer for waypoint", i, ":", wp.fade_layer);
                        getOrCreateLayer(wp.fade_layer);
                    }

                    // For the current waypoint, bring to front
                    if (i === currentWaypoint) {
                        bringLayerToFront(wp.url);
                        hideOtherLayers(wp.url, wp);
                    }
                }
            }

            // Jump directly to the target location and FOV
            aladin.setFov(waypoint.fov);
            aladin.gotoRaDec(waypoint.ra, waypoint.dec);

            // Reset interrupt flag
            interruptAnimation = false;

            console.log(`Jumped to waypoint ${currentWaypoint + 1} with all ${currentWaypoint + 1} layers loaded`);
        }

        // Custom FOV animation function using setFoV
        function animateFov(startFov, endFov, duration, callback) {
            const steps = 30;
            const stepDuration = duration / steps;
            let currentStep = 0;

            function doFovStep() {
                // Check if animation was interrupted
                if (interruptAnimation) {
                    aladin.setFov(endFov); // Jump to final FOV
                    if (callback) callback();
                    return;
                }

                currentStep++;
                const progress = currentStep / steps;

                // Easing function for smoother animation
                const easedProgress = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                // Calculate current FOV
                const currentFov = startFov + (endFov - startFov) * easedProgress;

                // Set the FOV
                aladin.setFov(currentFov);

                // Continue or complete
                if (currentStep < steps) {
                    setTimeout(doFovStep, stepDuration);
                } else {
                    aladin.setFov(endFov); // Make sure we end at the exact target FOV
                    if (callback) callback();
                }
            }

            // Start animation
            doFovStep();
        }

                // Fade animation function for image layers
        function animateFade(fadeOutTime, fadeDelay, fadeInTime, callback) {
            const activeLayer = getCurrentActiveLayer();
            if (!activeLayer) {
                console.warn('No current image layer to fade');
                if (callback) callback();
                return;
            }

            // Fade out the layer
            animateLayerOpacity(activeLayer, 1, 0, fadeOutTime, function() {
                // Check if animation was interrupted
                if (interruptAnimation) {
                    activeLayer.setOpacity(1);
                    if (callback) callback();
                    return;
                }

                // Wait for delay, then fade back in
                setTimeout(() => {
                    if (interruptAnimation) {
                        activeLayer.setOpacity(1);
                        if (callback) callback();
                        return;
                    }

                    animateLayerOpacity(activeLayer, 0, 1, fadeInTime, callback);
                }, fadeDelay * 1000);
            });
        }

                // Helper function to animate layer opacity
        function animateLayerOpacity(layer, startOpacity, endOpacity, duration, callback) {
            const steps = 30;
            const stepDuration = duration * 1000 / steps;
            let currentStep = 0;

            function doOpacityStep() {
                if (interruptAnimation) {
                    layer.setOpacity(endOpacity);
                    if (callback) callback();
                    return;
                }

                currentStep++;
                const progress = currentStep / steps;

                // Easing function for smoother animation
                const easedProgress = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                // Calculate current opacity
                const currentOpacity = startOpacity + (endOpacity - startOpacity) * easedProgress;

                // Set the layer opacity
                layer.setOpacity(currentOpacity);

                // Continue or complete
                if (currentStep < steps) {
                    setTimeout(doOpacityStep, stepDuration);
                } else {
                    layer.setOpacity(endOpacity); // Make sure we end at the exact target opacity
                    // Add a small buffer to ensure the final opacity change is fully processed
                    setTimeout(() => {
                        if (callback) callback();
                    }, 50); // 50ms buffer to ensure animation completion
                }
            }

            // Start animation
            doOpacityStep();
        }
    </script>
</body>

</html>