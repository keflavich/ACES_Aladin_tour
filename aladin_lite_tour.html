<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no">
    <title>ACES Star Formation Tour</title>
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src='https://aladin.cds.unistra.fr/AladinLite/api/v3/latest/aladin.js' charset='utf-8'></script>
    <!-- Add draggable functionality -->
    <script type="text/javascript" src="draggable.js"></script>
    <link rel="stylesheet" href="default.css">
    <link rel="stylesheet" href="draggable.css">
    <style>
        /* Mobile-friendly improvements */
        #progress-container {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #progress-bar {
            flex: 1;
            height: 4px !important;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            overflow: hidden;
        }

        #progress {
            height: 100%;
            background: #2962FF;
            transition: width 0.3s ease;
        }

        #current-waypoint {
            color: white;
            font-size: 14px;
            font-weight: bold;
            min-width: 30px;
            text-align: center;
        }

        #tour-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            width: 100%;
            max-width: 100vw;
            box-sizing: border-box;
            padding: 0 10px;
        }

        /* Desktop: only as wide as needed */
        @media (min-width: 769px) {
            #tour-controls {
                width: fit-content;
                padding: 0;
            }
        }

        #tour-controls button {
            background: #2962FF;
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            min-width: 48px;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }

        #tour-controls button:hover {
            background: #1976D2;
        }

        #tour-controls button:active {
            background: #0D47A1;
        }

        #tour-controls button:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
        }

        #tour-controls button:disabled:hover {
            background: #666;
        }

        #waypoint-info {
            max-width: 90vw;
            transition: all 0.3s ease;
        }

        /* Override any default positioning for mobile only */
        @media (max-width: 768px) {
            #waypoint-info {
                position: relative !important;
                left: auto !important;
                right: auto !important;
                top: auto !important;
                bottom: auto !important;
                width: fit-content !important;
                max-width: calc(100vw - 20px) !important;
                margin: 10px auto !important;
            }
        }

        /* Desktop: static positioning on top-right */
        @media (min-width: 769px) {
            #waypoint-info {
                position: absolute !important;
                width: auto !important;
                max-width: 400px !important;
                margin: 0 !important;
                left: auto !important;
                right: 20px !important;
                top: 20px !important;
                bottom: auto !important;
                transform: none !important;
                min-width: auto !important;
                max-height: none !important;
                /* Override any flex or grid positioning that might interfere */
                flex: none !important;
                align-self: auto !important;
                justify-self: auto !important;
            }
        }

        #waypoint-header {
            display: flex;
            align-items: center;
            gap: 10px;
            width: fit-content;
        }

                #waypoint-title {
            font-size: 24px;
            margin: 0;
            flex: 0 1 auto;
            line-height: 1.2;
        }

                #expand-btn {
            background: transparent;
            color: white;
            border: none;
            padding: 0;
            cursor: pointer;
            font-size: 14px;
            font-weight: normal;
            transition: opacity 0.2s ease;
            flex-shrink: 0;
            opacity: 0.7;
        }

        #expand-btn:hover {
            opacity: 1;
        }

        #waypoint-content {
            margin-top: 10px;
        }

        #waypoint-description {
            font-size: 16px;
            line-height: 1.4;
            margin: 0;
        }

                /* Mobile specific adjustments */
        @media (max-width: 768px) {
            #tour-controls {
                gap: 6px;
                padding: 0 5px;
            }

            #tour-controls button {
                padding: 12px 14px;
                font-size: 18px;
                min-width: 46px;
                min-height: 46px;
                flex: 0 1 auto;
            }

            #waypoint-dropdown {
                width: 32px !important;
                padding: 12px 4px !important;
                font-size: 14px !important;
            }

                        #waypoint-info {
                padding: 20px 15px;
                margin: 10px auto !important;
                max-width: calc(100vw - 20px);
                position: relative !important;
                left: auto !important;
                right: auto !important;
                top: auto !important;
                bottom: auto !important;
                width: fit-content !important;
            }

            #waypoint-info.collapsed #waypoint-content {
                display: none;
            }

            #waypoint-info.expanded {
                position: fixed !important;
                top: 10px !important;
                left: 10px !important;
                right: 10px !important;
                bottom: auto !important;
                max-height: 70vh;
                overflow-y: auto;
                z-index: 1000;
                background: rgba(0, 0, 0, 0.9);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
                width: auto !important;
                margin: 0 !important;
            }

                        #waypoint-title {
                font-size: 28px;
                font-weight: bold;
            }

            #waypoint-description {
                font-size: 16px;
            }

            #expand-btn {
                font-size: 16px;
            }
        }

        /* Very narrow screens (iPhone SE, etc.) */
        @media (max-width: 400px) {
            #tour-controls {
                gap: 4px;
                padding: 0 3px;
            }

            #tour-controls button {
                padding: 10px 12px;
                font-size: 16px;
                min-width: 40px;
                min-height: 40px;
                flex: 1 1 auto;
                max-width: 60px;
            }

            #waypoint-dropdown {
                width: 28px !important;
                padding: 10px 2px !important;
                font-size: 12px !important;
                flex: 0 0 28px;
            }

            #progress-container {
                margin: 0 3px 8px 3px;
                padding: 6px 10px;
            }

                        #waypoint-info {
                margin: 10px auto !important;
                padding: 18px 12px;
                max-width: calc(100vw - 15px);
                position: relative !important;
                left: auto !important;
                right: auto !important;
                top: auto !important;
                bottom: auto !important;
                width: fit-content !important;
            }

            #waypoint-info.expanded {
                top: 5px !important;
                left: 5px !important;
                right: 5px !important;
                max-height: 75vh;
                padding: 15px;
                margin: 0 !important;
            }

                        #waypoint-title {
                font-size: 24px;
                font-weight: bold;
            }

            #waypoint-description {
                font-size: 15px;
            }

            #expand-btn {
                font-size: 14px;
            }
        }

        /* Countdown Timer */
        #countdown-timer {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        #countdown-value {
            color: #2962FF;
            font-size: 16px;
        }

        @media (max-width: 768px) {
            #countdown-timer {
                bottom: 10px;
                right: 10px;
                font-size: 12px;
                padding: 6px 10px;
            }

            #countdown-value {
                font-size: 14px;
            }
        }
    </style>
</head>

<body>
    <div id="aladin-lite-div"></div>

    <div id="loading-div">Loading ACES Star Formation Tour... Please wait.</div>

    <div id="waypoint-info">
        <div id="waypoint-header">
            <button id="expand-btn" title="Expand/Collapse Info">▶</button>
            <h2 id="waypoint-title">Welcome to the ACES Central Molecular Zone Tour</h2>
        </div>
        <div id="waypoint-content">
            <p id="waypoint-description">
            This is a brief tour through the ACES view of the Central Molecular Zone.  Click "Start Tour" to begin.
            </p>
        </div>
    </div>

    <div id="progress-container">
        <div id="progress-bar">
            <div id="progress"></div>
        </div>
        <span id="current-waypoint">0</span>
    </div>

    <div id="tour-controls">
        <button id="prev-btn" title="Previous">‹</button>
        <button id="next-btn" title="Next">›</button>
        <button id="start-btn" title="Start/Play Tour">▶</button>
        <button id="reset-btn" title="Reset">⟲</button>
        <select id="waypoint-dropdown" title="Jump to waypoint"
            style="background-color: #2962FF; color: white; border: none; padding: 12px 6px; border-radius: 8px; margin: 0 3px; cursor: pointer; font-size: 16px; position: relative; z-index: 120; width: 36px; text-align: center; -webkit-appearance: none; -moz-appearance: none; appearance: none;">
            <option value="">≫</option>
        </select>
        <select id="speed-dropdown" title="Tour speed"
            style="background-color: #2962FF; color: white; border: none; padding: 12px 6px; border-radius: 8px; margin: 0 3px; cursor: pointer; font-size: 16px; position: relative; z-index: 120; width: 42px; text-align: center; -webkit-appearance: none; -moz-appearance: none; appearance: none;">
            <option value="1" selected>1×</option>
            <option value="2">2×</option>
            <option value="4">4×</option>
        </select>
    </div>

    <div id="countdown-timer" style="display: none;">
        <span id="countdown-text">Next in: </span>
        <span id="countdown-value">5</span>
    </div>

    <script>
        let aladin;
        let currentWaypoint = 0;
        let isPlaying = false;
        let waypointTimeout;
        let loopTour = true; // Flag to enable continuous looping (default on)
        let interruptAnimation = false; // Flag to interrupt ongoing animations
        let currentImageLayer = null; // Track the most recently added image layer
        let isInfoExpanded = false; // Track info panel state
        let countdownInterval = null; // Track countdown timer
        let countdownEndTime = null; // When the countdown should end

        // Layer management system to avoid reloading layers
        let layerCache = new Map(); // URL -> layer object mapping
        let layerOrder = []; // Track layer order for bringing to front
        let layerCounter = 0; // Counter for generating unique layer names

        // Speed control system
        let speedMultiplier = 1; // 1 = normal, 2 = 2x speed, 4 = 4x speed

        // Function to get or create a layer, reusing existing ones
        function getOrCreateLayer(url) {
            if (!url) return null;

            // Check if we already have this layer cached
            if (layerCache.has(url)) {
                console.log("Reusing existing layer for URL:", url);
                return layerCache.get(url);
            }

            // Create a new layer with a unique name
            layerCounter++;
            const layerName = `layer_${layerCounter}`;

            console.log("Creating new layer for URL:", url, "with name:", layerName);

            let layer;
            if (url.endsWith('.jpg')) {
                // For JPG files, we can't use overlay layers, so handle differently
                aladin.displayJPG(url);
                // Store a reference but note it's not a true layer object
                layerCache.set(url, { isJPG: true, url: url });
                return layerCache.get(url);
            } else {
                // Create an overlay image layer with a unique name
                const survey = aladin.newImageSurvey(url);
                layer = survey;
                aladin.setOverlayImageLayer(survey, layerName);

                // Cache the layer
                layerCache.set(url, { layer: layer, name: layerName, url: url });
                layerOrder.push(url);

                return layerCache.get(url);
            }
        }

        // Function to bring a layer to the foreground
        function bringLayerToFront(url) {
            if (!url || !layerCache.has(url)) return;

            const cachedLayer = layerCache.get(url);

            if (cachedLayer.isJPG) {
                // For JPG layers, we need to redisplay them
                console.log("Bringing JPG layer to front:", url);
                aladin.displayJPG(url);
                return cachedLayer;
            }

            // For regular layers, make sure it's visible and has full opacity
            if (cachedLayer.layer) {
                console.log("Bringing layer to front:", url, "name:", cachedLayer.name);
                cachedLayer.layer.setOpacity(1.0);

                // Update the layer order
                const index = layerOrder.indexOf(url);
                if (index > -1) {
                    layerOrder.splice(index, 1);
                }
                layerOrder.push(url);

                // Set as current image layer
                currentImageLayer = cachedLayer.layer;

                // Debug: show cache status
                if (console.log) {
                    showLayerCacheStatus();
                }

                return cachedLayer;
            }
        }

        // Function to hide other layers (optional, for cleaner display)
        function hideOtherLayers(currentUrl) {
            layerCache.forEach((cachedLayer, url) => {
                if (url !== currentUrl && !cachedLayer.isJPG && cachedLayer.layer) {
                    // Reduce opacity instead of completely hiding to maintain performance
                    cachedLayer.layer.setOpacity(0.1);
                }
            });
        }

        // Function to clear layer cache (useful for reset)
        function clearLayerCache() {
            console.log("Clearing layer cache");
            layerCache.clear();
            layerOrder = [];
            layerCounter = 0;
            currentImageLayer = null;
        }

        // Function to get current active layer for animations
        function getCurrentActiveLayer() {
            // Try to find the most recently activated layer
            if (layerOrder.length > 0) {
                const lastUrl = layerOrder[layerOrder.length - 1];
                const cachedLayer = layerCache.get(lastUrl);
                if (cachedLayer && !cachedLayer.isJPG && cachedLayer.layer) {
                    return cachedLayer.layer;
                }
            }
            return currentImageLayer; // Fallback to old system
        }

        // Debug function to show layer cache status
        function showLayerCacheStatus() {
            console.log("=== Layer Cache Status ===");
            console.log("Total cached layers:", layerCache.size);
            console.log("Layer order:", layerOrder);
            layerCache.forEach((cachedLayer, url) => {
                const type = cachedLayer.isJPG ? "JPG" : "HiPS";
                const opacity = cachedLayer.layer ? cachedLayer.layer.getAlpha() : "N/A";
                console.log(`- ${url}: ${type}, opacity: ${opacity}`);
            });
            console.log("========================");
        }

        // Initialize mobile info panel
        function initializeMobileInfoPanel() {
            const infoPanel = document.getElementById('waypoint-info');
            const expandBtn = document.getElementById('expand-btn');

            // Set initial state based on screen size
            if (window.innerWidth <= 768) {
                infoPanel.classList.add('collapsed');
                isInfoExpanded = false;
                expandBtn.innerHTML = '▶';
                expandBtn.title = 'Expand Info';
            } else {
                infoPanel.classList.remove('collapsed', 'expanded');
                expandBtn.style.display = 'none';
            }

            // Add expand button event listener
            expandBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                toggleInfoPanel();
            });

                        // Handle window resize
            window.addEventListener('resize', function() {
                if (window.innerWidth > 768) {
                    // Desktop view - hide expand button and reset state
                    infoPanel.classList.remove('collapsed', 'expanded');
                    expandBtn.style.display = 'none';
                    isInfoExpanded = false;
                } else {
                    // Mobile view - show expand button and set collapsed state
                    expandBtn.style.display = 'block';
                    if (!isInfoExpanded) {
                        infoPanel.classList.add('collapsed');
                        infoPanel.classList.remove('expanded');
                    }
                }
            });
        }

        // Toggle info panel expand/collapse
        function toggleInfoPanel() {
            const infoPanel = document.getElementById('waypoint-info');
            const expandBtn = document.getElementById('expand-btn');

            if (isInfoExpanded) {
                // Collapse
                infoPanel.classList.remove('expanded');
                infoPanel.classList.add('collapsed');
                expandBtn.innerHTML = '▶';
                expandBtn.title = 'Expand Info';
                isInfoExpanded = false;
            } else {
                // Expand
                infoPanel.classList.remove('collapsed');
                infoPanel.classList.add('expanded');
                expandBtn.innerHTML = '▼';
                expandBtn.title = 'Collapse Info';
                isInfoExpanded = true;
            }
        }

        // Countdown timer functions
        function startCountdown(durationMs) {
            if (!isPlaying) return;

            stopCountdown(); // Clear any existing countdown

            countdownEndTime = Date.now() + durationMs;
            const countdownTimer = document.getElementById('countdown-timer');
            const countdownValue = document.getElementById('countdown-value');

            countdownTimer.style.display = 'block';

            function updateCountdown() {
                if (!isPlaying || !countdownEndTime) {
                    stopCountdown();
                    return;
                }

                const timeLeft = countdownEndTime - Date.now();
                if (timeLeft <= 0) {
                    stopCountdown();
                    return;
                }

                const secondsLeft = Math.ceil(timeLeft / 1000);
                countdownValue.textContent = secondsLeft;
            }

            // Update immediately and then every 100ms for smooth countdown
            updateCountdown();
            countdownInterval = setInterval(updateCountdown, 100);
        }

        function stopCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            countdownEndTime = null;
            document.getElementById('countdown-timer').style.display = 'none';
        }

        // Function to advance to the next waypoint
        function autoAdvance() {
            if (!isPlaying) return;
            if (currentWaypoint < waypoints.length - 1) {
                goToWaypoint(currentWaypoint + 1);
            } else if (loopTour) {
                goToWaypoint(0);
            } else {
                isPlaying = false;
                return;
            }
            // Note: timeout is now set in goToWaypoint() after animation completes
        }


        // Define waypoints for the tour
        const waypoints = [
            {
                ra: 266.416667,
                dec: -29.008333,
                fov: 3.0,
                transition_fov: 3.0,
                transition_time: 2,
                zoom_out_time: 0,
                zoom_in_time: 2,
                title: "The CMZ",
                description: "The Central Molecular Zone seen with MEERKAT and Spitzer.  Color composite by Ashley Barnes.",
                url: "rgb_final_uncropped_hips",
                pause_time: 5000  // Brief introduction
            },
            {
                ra: 266.416667,
                dec: -29.008333,
                fov: 0.8,
                transition_fov: 3.0,
                transition_time: 3,
                zoom_out_time: 2,
                zoom_in_time: 3,
                title: "ACES",
                description: "The ALMA Central Molecular Zone survey (ACES) combined with the Green Bank Telescope's MUSTANG survey in the Galactic Center.  This is the highest-resolution millimeter image produced of the Galactic Center.",
                url: "MUSTANG_12m_feather_noaxes_hips/",
                fade_enabled: true,
                fade_out_time: 1.5,
                fade_delay: 0.5,
                fade_in_time: 1.5,
                pause_time: 2000  // Short pause after fade
            },
            {
                ra: 266.835223,
                dec: -28.3958813,
                fov: 0.1,
                transition_fov: 0.8,
                transition_time: 3,
                zoom_out_time: 2,
                zoom_in_time: 3,
                title: "Sgr B2 with ALMA",
                description: "The Sgr B2 cloud is our Galaxy's most massive and active star-forming region.  It contains several high-mass protoclusters, Sgr B2 N and M, and a third that's a bit smaller, S. \n  This image shows the medium-resolution view of Sgr B2 with ALMA from Ginsburg+ 2018. ",
                url: "feathered_MGPS_ALMATCTE7m_hips/",
                fade_enabled: true,
                fade_out_time: 1.5,
                fade_delay: 0.5,
                fade_in_time: 1.5,
                pause_time: 3000  // Medium pause after fade
            },
            {
                ra: 266.83311023,
                dec: -28.37178279,
                fov: 0.006,
                transition_fov: 1,
                transition_time: 5,
                zoom_out_time: 3,
                zoom_in_time: 5,
                title: "Sgr B2N",
                description: "Sagittarius B2 North is the most massive site of ongoing star formation in the Milky Way.  Within a region less than a tenth of a parsec across, thousands of solar masses of gas are flowing into a central massive-star-forming protocluster birthing several proto-O-stars within only a few thousand astronomical units.  \n Data by Nazar Budaiev.",
                url: "GINSBURG_P_SgrB2N_RGB/",
                fade_enabled: true,
                fade_out_time: 2,
                fade_delay: 0.5,
                fade_in_time: 2,
                pause_time: 4000  // Longer pause for detailed view
            },
            {
                ra: 266.833992,
                dec: -28.38459,
                fov: 0.006,
                transition_fov: 0.012,
                transition_time: 5,
                zoom_out_time: 3,
                zoom_in_time: 5,
                title: "Sgr B2M",
                description: "Sgr B2M is the most massive embedded star cluster in the Galactic Center.  The image shows several HII regions, sites where massive stars have ionized their surroundings, within a tiny volume.   \n Data by Nazar Budaiev.",
                url: "GINSBURG_P_SgrB2M_RGB/",
                fade_enabled: true,
                fade_out_time: 1,
                fade_delay: 0.5,
                fade_in_time: 1,
                pause_time: 3000,  // Final dramatic pause
                end_of_tour_pause: 5000  // Special pause before looping
            },
            {
                ra: 266.833992,
                dec: -28.38459,
                fov: 0.006,
                transition_fov: 0.012,
                transition_time: 5,
                zoom_out_time: 3,
                zoom_in_time: 5,
                url: "SgrB2_RGB_480-405-187_scaled_hips/",
                title: "Sgr B2 RGB",
                description: "The Sgr B2 cloud seen with JWST.  This is a composite of the 405, 356, and 200 micron bands.  \n Data by Nazar Budaiev & Adam Ginsburg.",
                pause_time: 1000
            },
            {
                ra: 266.835223,
                dec: -28.3958813,
                fov: 0.1,
                transition_fov: 0.1,
                transition_time: 5,
                zoom_out_time: 3,
                zoom_in_time: 5,
                url: "SgrB2_RGB_480-405-187_scaled_hips/",
                title: "Sgr B2 RGB",
                description: "The Sgr B2 cloud seen with JWST.  This is a composite of the 405, 356, and 200 micron bands.  \n Data by Nazar Budaiev & Adam Ginsburg.",
            },
            {
                ra: 266.541320,
                dec: -28.7088928,
                fov: 0.1,
                transition_fov: 0.5,
                transition_time: 5,
                zoom_out_time: 3,
                zoom_in_time: 5,
                url: "BrickJWST_1182p2221_405_356_200_hips/",
                title: "Brick JWST",
                description: "The Brick JWST image of the Galactic Center.  This is a composite of the 405, 356, and 200 micron bands.  \n Ginsburg et al 2023.",
                pause_time: 5000
            },
        ];

        // Initialize Aladin once the page is loaded
        document.addEventListener('DOMContentLoaded', function () {
            console.log('Document loaded, waiting for A.init to complete');

                        // Make controls draggable (waypoint-info is static)
            makeDraggable(document.getElementById('progress-container'));
            makeDraggable(document.getElementById('tour-controls'));

            // Initialize mobile info panel state
            initializeMobileInfoPanel();

            // Prevent dropdown from being affected by draggable behavior
            const dropdown = document.getElementById('waypoint-dropdown');
            dropdown.addEventListener('mousedown', function (e) {
                e.stopPropagation(); // Stop the event from bubbling up
            });
            dropdown.addEventListener('click', function (e) {
                e.stopPropagation(); // Stop the event from bubbling up
            });
            dropdown.addEventListener('focus', function (e) {
                e.stopPropagation(); // Stop the event from bubbling up
            });

            // Wait for A.init promise to complete (required for v3 API)
            A.init.then(() => {
                console.log('A.init completed, creating Aladin instance');

                aladin = A.aladin('#aladin-lite-div', {
                    survey: 'rgb_final_uncropped_hips/',
                    // survey: "IPAC/P/GLIMPSE360",
                    //;'"P/2MASS/color",
                    fov: waypoints[0].fov,
                    target: waypoints[0].ra + ' ' + waypoints[0].dec,
                    cooFrame: 'GAL',
                    showReticle: false,
                    showZoomControl: true,
                    showFullscreenControl: true,
                    showLayersControl: true,
                    showGotoControl: true,
                    showFrame: true,
                    showCooGrid: false,
                    showSimbadPointerControl: true,
                    showSettingsControl: true,
                    showShareControl: true,
                });


                // Initialize the first layer using our caching system
                const initialCachedLayer = getOrCreateLayer('rgb_final_uncropped_hips/');
                bringLayerToFront('rgb_final_uncropped_hips/');

                // Also cache the first waypoint's layer if it's different
                if (waypoints[0].url && waypoints[0].url !== 'rgb_final_uncropped_hips/') {
                    getOrCreateLayer(waypoints[0].url);
                }

                // Hide loading message
                document.getElementById('loading-div').style.display = 'none';

                // Populate waypoint dropdown
                populateWaypointDropdown();

                updateWaypointInfo();
                updateProgressBar();
                goToWaypointFast(0);

                // Set up event listeners for the buttons
                document.getElementById('prev-btn').addEventListener('click', function () {
                    isPlaying = false;
                    clearTimeout(waypointTimeout);
                    stopCountdown();
                    updatePlayPauseButton();
                    goToWaypoint(currentWaypoint - 1);
                });

                // document.getElementById('next-btn-fast').addEventListener('click', function() {
                //     console.log("Clicked next-btn-fast.  Current waypoint: ", currentWaypoint);
                //     if (currentWaypoint === waypoints.length - 1) {
                //         // If at the last waypoint, reset to the beginning
                //         goToWaypointFast(0);
                //         return;
                //     } else {
                //         isPlaying = false;
                //         goToWaypointFast(currentWaypoint + 1);
                //     }
                // });

                document.getElementById('next-btn').addEventListener('click', function () {
                    if (currentWaypoint === waypoints.length - 1) {
                        // If at the last waypoint, reset to the beginning
                        isPlaying = false;
                        clearTimeout(waypointTimeout);
                        stopCountdown();
                        updatePlayPauseButton();
                        goToWaypoint(0);
                        return;
                    }

                    // Just advance to next waypoint without auto-playing
                    isPlaying = false;
                    clearTimeout(waypointTimeout);
                    stopCountdown();
                    updatePlayPauseButton();
                    goToWaypoint(currentWaypoint + 1);
                });

                document.getElementById('start-btn').addEventListener('click', function () {
                    if (isPlaying) {
                        // Pause the tour
                        pauseTour();
                    } else {
                        // Start/resume the tour
                        startTour();
                    }
                });

                document.getElementById('reset-btn').addEventListener('click', function () {
                    isPlaying = false;
                    clearTimeout(waypointTimeout);
                    stopCountdown();
                    updatePlayPauseButton();
                    goToWaypoint(0);
                });



                // Set up waypoint dropdown event listener
                document.getElementById('waypoint-dropdown').addEventListener('change', function () {
                    const selectedIndex = parseInt(this.value);
                    if (!isNaN(selectedIndex)) {
                        isPlaying = false;
                        clearTimeout(waypointTimeout);
                        stopCountdown();
                        updatePlayPauseButton();
                        jumpToWaypointWithLayers(selectedIndex);
                        // Reset dropdown to default after selection
                        this.selectedIndex = 0;
                    }
                });

                // Set up speed dropdown event listener
                document.getElementById('speed-dropdown').addEventListener('change', function () {
                    const selectedSpeed = parseFloat(this.value);
                    if (!isNaN(selectedSpeed) && selectedSpeed > 0) {
                        speedMultiplier = selectedSpeed;
                        console.log("Speed multiplier set to:", speedMultiplier);

                        // If currently playing, restart countdown with new timing
                        if (isPlaying && countdownEndTime) {
                            const remainingTime = countdownEndTime - Date.now();
                            if (remainingTime > 0) {
                                // Adjust remaining time based on new speed
                                const adjustedTime = remainingTime / speedMultiplier;
                                startCountdown(adjustedTime);
                            }
                        }
                    }
                });
            }).catch(err => {
                console.error('Failed to initialize Aladin:', err);
                document.getElementById('loading-div').textContent = 'Error loading Aladin. Please refresh the page.';
            });
        });

        // Function to update the waypoint information
        function updateWaypointInfo() {
            document.getElementById('waypoint-title').innerText = waypoints[currentWaypoint].title;
            document.getElementById('waypoint-description').innerText = waypoints[currentWaypoint].description;
            document.getElementById('current-waypoint').innerText = (currentWaypoint + 1) + '/' + waypoints.length;

            // Update button states
            updateButtonStates();
        }

        // Function to update button states
        function updateButtonStates() {
            const prevBtn = document.getElementById('prev-btn');

            // Disable previous button at first waypoint
            if (currentWaypoint === 0) {
                prevBtn.disabled = true;
                prevBtn.title = 'Previous (unavailable)';
            } else {
                prevBtn.disabled = false;
                prevBtn.title = 'Previous';
            }

            // Update next button text to show the next region name
            updateNextButtonText();

            // Update play/pause button
            updatePlayPauseButton();
        }

        // Function to update play/pause button appearance
        function updatePlayPauseButton() {
            const playBtn = document.getElementById('start-btn');
            if (isPlaying) {
                playBtn.innerHTML = '⏸';
                playBtn.title = 'Pause Tour';
            } else {
                playBtn.innerHTML = '▶';
                playBtn.title = 'Play/Resume Tour';
            }
        }

                // Function to start/resume the tour
        function startTour() {
            isPlaying = true;
            interruptAnimation = false;  // Reset interrupt flag for new animations
            updatePlayPauseButton();

            // If starting from waypoint 0, immediately go to waypoint 1 to start the tour
            if (currentWaypoint === 0) {
                goToWaypoint(1);
            } else {
                goToWaypoint(currentWaypoint);
            }
        }

        // Function to pause the tour
        function pauseTour() {
            isPlaying = false;
            interruptAnimation = true;  // Halt any ongoing animations immediately
            clearTimeout(waypointTimeout);
            stopCountdown();
            updatePlayPauseButton();
        }

        // Function to populate the waypoint dropdown
        function populateWaypointDropdown() {
            const dropdown = document.getElementById('waypoint-dropdown');
            // Clear existing options except the first one
            while (dropdown.options.length > 1) {
                dropdown.remove(1);
            }

            // Add all waypoints
            waypoints.forEach((waypoint, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.text = `${index + 1}. ${waypoint.title}`;
                dropdown.appendChild(option);
            });
        }

        // Function to update the next button text
        function updateNextButtonText() {
            if (currentWaypoint === waypoints.length - 1) {
                // At last waypoint, show restart symbol
                document.getElementById('next-btn').innerHTML = '↻';
                document.getElementById('next-btn').title = 'Restart Tour';
            } else {
                // Show next symbol with tooltip showing next waypoint
                const nextWaypoint = waypoints[currentWaypoint + 1];
                document.getElementById('next-btn').innerHTML = '›';
                document.getElementById('next-btn').title = 'Next: ' + nextWaypoint.title;
            }

            // Highlight the current waypoint in the dropdown
            const dropdown = document.getElementById('waypoint-dropdown');
            Array.from(dropdown.options).forEach((option, index) => {
                if (index > 0 && parseInt(option.value) === currentWaypoint) {
                    option.style.backgroundColor = '#0D47A1';
                } else if (index > 0) {
                    option.style.backgroundColor = '';
                }
            });
        }

        // Function to update the progress bar
        function updateProgressBar() {
            const progress = ((currentWaypoint) / (waypoints.length - 1)) * 100;
            document.getElementById('progress').style.width = progress + '%';
        }

        function goToWaypointFast(index) {
            if (!aladin) {
                console.error('Aladin not initialized yet');
                return;
            }

            // Signal to interrupt any ongoing animation
            interruptAnimation = true;
            clearTimeout(waypointTimeout);

            // Update current waypoint state
            currentWaypoint = index;
            if (currentWaypoint < 0) currentWaypoint = 0;
            if (currentWaypoint >= waypoints.length) currentWaypoint = waypoints.length - 1;

            // Get the waypoint data
            const waypoint = waypoints[currentWaypoint];

            // Update display info
            updateWaypointInfo();
            updateProgressBar();

            // Display image if available
            if (waypoint.url) {
                console.log("Displaying layer (fast): ", waypoint.url);
                const cachedLayer = getOrCreateLayer(waypoint.url);
                bringLayerToFront(waypoint.url);
                // Optionally hide other layers for cleaner display
                hideOtherLayers(waypoint.url);
            }

            // Jump directly to the location
            aladin.setFov(waypoint.fov);
            aladin.gotoRaDec(waypoint.ra, waypoint.dec);

            // Reset interrupt flag
            interruptAnimation = false;
        }

        // Function to go to a specific waypoint with animation
        function goToWaypoint(index) {
            if (!aladin) {
                console.error('Aladin not initialized yet');
                return;
            }

            // Reset interrupt flag at the start of a new animation
            interruptAnimation = false;
            clearTimeout(waypointTimeout);

            currentWaypoint = index;
            if (currentWaypoint < 0) currentWaypoint = 0;
            if (currentWaypoint >= waypoints.length) currentWaypoint = waypoints.length - 1;

            const waypoint = waypoints[currentWaypoint];

            // Only update progress bar immediately, delay waypoint info until animation starts
            updateProgressBar();

            // Only stop the tour if we're at the last waypoint and not looping
            if (currentWaypoint === waypoints.length - 1 && !loopTour) {
                isPlaying = false;
                clearTimeout(waypointTimeout);
                updatePlayPauseButton();
            }

            // Calculate total transition time and start countdown immediately if playing
            if (isPlaying && currentWaypoint < waypoints.length - 1) {
                const prevIndex = currentWaypoint > 0 ? currentWaypoint - 1 : 0;
                const prevWaypoint = waypoints[prevIndex];

                // Calculate distance to determine if this is close or distant waypoints
                const distance = Math.sqrt(
                    Math.pow(waypoint.ra - prevWaypoint.ra, 2) +
                    Math.pow(waypoint.dec - prevWaypoint.dec, 2)
                );

                let totalTime = 0;

                if (distance < 0.2) {
                    // Close waypoints: 2s movement + optional fade + pause
                    totalTime = 2000; // animateToRaDec time
                } else {
                    // Distant waypoints: zoom out + movement + zoom in + optional fade + pause
                    totalTime = (waypoint.zoom_out_time * 1000) + (waypoint.transition_time * 1000) + (waypoint.zoom_in_time * 1000);
                }

                // Add fade time if enabled
                if (waypoint.fade_enabled) {
                    totalTime += (waypoint.fade_out_time * 1000) + (waypoint.fade_delay * 1000) + (waypoint.fade_in_time * 1000);
                }

                // Add pause time
                totalTime += waypoint.pause_time || 2000;

                // Start countdown for total time
                startCountdown(totalTime);
            } else if (isPlaying && currentWaypoint === waypoints.length - 1 && loopTour) {
                // Handle end of tour countdown
                const endPause = waypoint.end_of_tour_pause || waypoint.pause_time || 5000;
                startCountdown(endPause);
            }

            const prevIndex = currentWaypoint > 0 ? currentWaypoint - 1 : 0;
            const prevWaypoint = waypoints[prevIndex];

            // Calculate distance between current and previous waypoints
            const distance = Math.sqrt(
                Math.pow(waypoint.ra - prevWaypoint.ra, 2) +
                Math.pow(waypoint.dec - prevWaypoint.dec, 2)
            );

            // If waypoints are close (within 0.1 degrees), skip zoom out step
            if (distance < 0.2) {
                console.log("Close waypoints detected, skipping zoom out step");
                // Update waypoint info right before starting the movement animation
                updateWaypointInfo();
                // Go directly to the new coordinates
                aladin.animateToRaDec(waypoint.ra, waypoint.dec, 2, function () {
                    // Check if animation was interrupted
                    if (interruptAnimation) return;

                    if (waypoints[index].url) {
                        console.log("Displaying layer: ", waypoints[index].url);
                        const cachedLayer = getOrCreateLayer(waypoints[index].url);
                        bringLayerToFront(waypoints[index].url);
                        // Optionally hide other layers for cleaner display
                        hideOtherLayers(waypoints[index].url);
                    }

                    // Then zoom in to target FOV
                    aladin.zoomToFoV(waypoint.fov, waypoint.transition_time, function () {
                        // Check if animation was interrupted
                        if (interruptAnimation) return;

                        // Check if fade animation is enabled for this waypoint
                        if (waypoint.fade_enabled) {
                            animateFade(waypoint.fade_out_time, waypoint.fade_delay, waypoint.fade_in_time, function() {
                                // Set up auto-advance timeout using configurable pause time
                                if (isPlaying) {
                                    if (currentWaypoint === waypoints.length - 1 && loopTour) {
                                        console.log("End of tour reached, looping back to start");
                                        clearTimeout(waypointTimeout);
                                        const endPause = waypoint.end_of_tour_pause || waypoint.pause_time || 3000;
                                        waypointTimeout = setTimeout(autoAdvance, endPause);
                                    } else if (currentWaypoint < waypoints.length - 1) {
                                        // Schedule next waypoint using configurable pause time
                                        clearTimeout(waypointTimeout);
                                        const pauseTime = waypoint.pause_time || 2000; // Default 2 seconds
                                        waypointTimeout = setTimeout(autoAdvance, pauseTime);
                                    }
                                }
                            });
                        } else {
                            // No fade animation, set up auto-advance timeout using configurable pause time
                            if (isPlaying) {
                                if (currentWaypoint === waypoints.length - 1 && loopTour) {
                                    console.log("End of tour reached, looping back to start");
                                    clearTimeout(waypointTimeout);
                                    const endPause = waypoint.end_of_tour_pause || waypoint.pause_time || 5000;
                                    waypointTimeout = setTimeout(autoAdvance, endPause);
                                } else if (currentWaypoint < waypoints.length - 1) {
                                    // Schedule next waypoint using configurable pause time
                                    clearTimeout(waypointTimeout);
                                    const pauseTime = waypoint.pause_time || (currentWaypoint === 0 ? 2000 : 8000); // Default values
                                    waypointTimeout = setTimeout(autoAdvance, pauseTime);
                                }
                            }
                        }
                    });
                });
            } else {
                // Multi-step animation with custom FOV animation
                // Step 1: Zoom out to 5 degrees
                aladin.zoomToFoV(waypoint.transition_fov, waypoint.zoom_out_time, function () {
                    // Check if animation was interrupted
                    if (interruptAnimation) return;

                    // Update waypoint info right before starting the movement animation
                    updateWaypointInfo();
                    // Step 2: Go to the new coordinates
                    aladin.animateToRaDec(waypoint.ra, waypoint.dec, waypoint.transition_time, function () {
                        // Check if animation was interrupted
                        if (interruptAnimation) return;

                        if (waypoints[index].url) {
                            console.log("Displaying layer: ", waypoints[index].url);
                            const cachedLayer = getOrCreateLayer(waypoints[index].url);
                            bringLayerToFront(waypoints[index].url);
                            // Optionally hide other layers for cleaner display
                            hideOtherLayers(waypoints[index].url);
                        }
                        // Step 3: Zoom in to target FOV
                        aladin.zoomToFoV(waypoint.fov, waypoint.zoom_in_time, function () {
                            // Check if animation was interrupted
                            if (interruptAnimation) return;

                            // Check if fade animation is enabled for this waypoint
                            if (waypoint.fade_enabled) {
                                animateFade(waypoint.fade_out_time, waypoint.fade_delay, waypoint.fade_in_time, function() {
                                    // Set up auto-advance timeout using configurable pause time
                                    if (isPlaying) {
                                        if (currentWaypoint === waypoints.length - 1 && loopTour) {
                                            console.log("End of tour reached, looping back to start");
                                            clearTimeout(waypointTimeout);
                                            const endPause = waypoint.end_of_tour_pause || waypoint.pause_time || 3000;
                                            waypointTimeout = setTimeout(autoAdvance, endPause);
                                        } else if (currentWaypoint < waypoints.length - 1) {
                                            // Schedule next waypoint using configurable pause time
                                            clearTimeout(waypointTimeout);
                                            const pauseTime = waypoint.pause_time || 2000; // Default 2 seconds
                                            waypointTimeout = setTimeout(autoAdvance, pauseTime);
                                        }
                                    }
                                });
                            } else {
                                // No fade animation, set up auto-advance timeout using configurable pause time
                                if (isPlaying) {
                                    if (currentWaypoint === waypoints.length - 1 && loopTour) {
                                        console.log("End of tour reached, looping back to start");
                                        clearTimeout(waypointTimeout);
                                        const endPause = waypoint.end_of_tour_pause || waypoint.pause_time || 5000;
                                        waypointTimeout = setTimeout(autoAdvance, endPause);
                                    } else if (currentWaypoint < waypoints.length - 1) {
                                        // Schedule next waypoint using configurable pause time
                                        clearTimeout(waypointTimeout);
                                        const pauseTime = waypoint.pause_time || 8000; // Default 8 seconds for multi-step
                                        waypointTimeout = setTimeout(autoAdvance, pauseTime);
                                    }
                                }
                            }
                        });
                    });
                });
            }
        }

        // Function to jump to a waypoint with all previous layers loaded
        function jumpToWaypointWithLayers(index) {
            if (!aladin) {
                console.error('Aladin not initialized yet');
                return;
            }

            // Signal to interrupt any ongoing animation
            interruptAnimation = true;
            clearTimeout(waypointTimeout);

            // Update current waypoint state
            currentWaypoint = index;
            if (currentWaypoint < 0) currentWaypoint = 0;
            if (currentWaypoint >= waypoints.length) currentWaypoint = waypoints.length - 1;

            // Get the target waypoint data
            const waypoint = waypoints[currentWaypoint];

            // Update display info
            updateWaypointInfo();
            updateProgressBar();

            // Load all image layers from waypoint 0 up to the selected waypoint
            for (let i = 0; i <= currentWaypoint; i++) {
                const wp = waypoints[i];
                if (wp.url) {
                    console.log("Ensuring layer exists for waypoint", i, ":", wp.url);
                    const cachedLayer = getOrCreateLayer(wp.url);
                    // For the current waypoint, bring to front
                    if (i === currentWaypoint) {
                        bringLayerToFront(wp.url);
                        hideOtherLayers(wp.url);
                    }
                }
            }

            // Jump directly to the target location and FOV
            aladin.setFov(waypoint.fov);
            aladin.gotoRaDec(waypoint.ra, waypoint.dec);

            // Reset interrupt flag
            interruptAnimation = false;

            console.log(`Jumped to waypoint ${currentWaypoint + 1} with all ${currentWaypoint + 1} layers loaded`);
        }

        // Custom FOV animation function using setFoV
        function animateFov(startFov, endFov, duration, callback) {
            const steps = 30;
            const stepDuration = duration / steps;
            let currentStep = 0;

            function doFovStep() {
                // Check if animation was interrupted
                if (interruptAnimation) {
                    aladin.setFov(endFov); // Jump to final FOV
                    if (callback) callback();
                    return;
                }

                currentStep++;
                const progress = currentStep / steps;

                // Easing function for smoother animation
                const easedProgress = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                // Calculate current FOV
                const currentFov = startFov + (endFov - startFov) * easedProgress;

                // Set the FOV
                aladin.setFov(currentFov);

                // Continue or complete
                if (currentStep < steps) {
                    setTimeout(doFovStep, stepDuration);
                } else {
                    aladin.setFov(endFov); // Make sure we end at the exact target FOV
                    if (callback) callback();
                }
            }

            // Start animation
            doFovStep();
        }

                // Fade animation function for image layers
        function animateFade(fadeOutTime, fadeDelay, fadeInTime, callback) {
            const activeLayer = getCurrentActiveLayer();
            if (!activeLayer) {
                console.warn('No current image layer to fade');
                if (callback) callback();
                return;
            }

            // Fade out the layer
            animateLayerOpacity(activeLayer, 1, 0, fadeOutTime, function() {
                // Check if animation was interrupted
                if (interruptAnimation) {
                    activeLayer.setOpacity(1);
                    if (callback) callback();
                    return;
                }

                // Wait for delay, then fade back in
                setTimeout(() => {
                    if (interruptAnimation) {
                        activeLayer.setOpacity(1);
                        if (callback) callback();
                        return;
                    }

                    animateLayerOpacity(activeLayer, 0, 1, fadeInTime, callback);
                }, fadeDelay * 1000);
            });
        }

                // Helper function to animate layer opacity
        function animateLayerOpacity(layer, startOpacity, endOpacity, duration, callback) {
            const steps = 30;
            const stepDuration = duration * 1000 / steps;
            let currentStep = 0;

            function doOpacityStep() {
                if (interruptAnimation) {
                    layer.setOpacity(endOpacity);
                    if (callback) callback();
                    return;
                }

                currentStep++;
                const progress = currentStep / steps;

                // Easing function for smoother animation
                const easedProgress = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                // Calculate current opacity
                const currentOpacity = startOpacity + (endOpacity - startOpacity) * easedProgress;

                // Set the layer opacity
                layer.setOpacity(currentOpacity);

                // Continue or complete
                if (currentStep < steps) {
                    setTimeout(doOpacityStep, stepDuration);
                } else {
                    layer.setOpacity(endOpacity); // Make sure we end at the exact target opacity
                    // Add a small buffer to ensure the final opacity change is fully processed
                    setTimeout(() => {
                        if (callback) callback();
                    }, 50); // 50ms buffer to ensure animation completion
                }
            }

            // Start animation
            doOpacityStep();
        }
    </script>
</body>

</html>